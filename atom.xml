<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>梁萧code</title>
  <icon>https://www.gravatar.com/avatar/781382200c2ff16f3447443c9fde679a</icon>
  <subtitle>记录学习中的点点滴滴</subtitle>
  <link href="https://liangxiaocode.github.io/atom.xml" rel="self"/>
  
  <link href="https://liangxiaocode.github.io/"/>
  <updated>2021-05-06T11:45:57.143Z</updated>
  <id>https://liangxiaocode.github.io/</id>
  
  <author>
    <name>梁路</name>
    <email>478697947@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>异步请求池框架实现</title>
    <link href="https://liangxiaocode.github.io/2021/05/06/%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82%E6%B1%A0%E6%A1%86%E6%9E%B6%E5%AE%9E%E7%8E%B0/"/>
    <id>https://liangxiaocode.github.io/2021/05/06/%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82%E6%B1%A0%E6%A1%86%E6%9E%B6%E5%AE%9E%E7%8E%B0/</id>
    <published>2021-05-05T16:00:00.000Z</published>
    <updated>2021-05-06T11:45:57.143Z</updated>
    
    <content type="html"><![CDATA[<h2 id="如何做一个异步请求？"><a href="#如何做一个异步请求？" class="headerlink" title="如何做一个异步请求？"></a>如何做一个异步请求？</h2><ol><li>一个连接还是多个连接？多个连接</li><li>网络IO的基础，发送对应的协议</li><li>既然是多个连接，发送完请求以后，响应没有接收以前，fd存储在哪？ –&gt;fd由epoll进行管理</li><li>请求与响应的数据，不能做到一个线程</li></ol><h2 id="如何设计？"><a href="#如何设计？" class="headerlink" title="如何设计？"></a>如何设计？</h2><h3 id="封装一组API："><a href="#封装一组API：" class="headerlink" title="封装一组API："></a>封装一组API：</h3><ul><li>commit:<ul><li>建立好网络连接</li><li>组织好对应的协议</li><li>send到对应的服务器</li><li>fd是否可读，fd加入epoll</li></ul></li><li>init：异步操作的上下文<ul><li>epoll_create</li><li>pthread_create</li></ul></li><li>callback:<ul><li>epoll_wait(),检测当前fd可读</li><li>recv(fd)，读出所有协议数据，并且解析</li></ul></li><li>destroy<ul><li>close</li><li>pthread_cancel</li></ul></li></ul><span id="more"></span><h3 id="异步快在哪里？"><a href="#异步快在哪里？" class="headerlink" title="异步快在哪里？"></a>异步快在哪里？</h3><ol><li>同步时串行，需要等待结果</li><li>异步是并行，只管发送请求，一起接收返回结果</li></ol><h2 id="以DNS为例，来实现异步请求池"><a href="#以DNS为例，来实现异步请求池" class="headerlink" title="以DNS为例，来实现异步请求池"></a>以DNS为例，来实现异步请求池</h2><h3 id="commit"><a href="#commit" class="headerlink" title="commit()"></a>commit()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dns_async_client_commit</span><span class="params">(struct async_context* ctx, <span class="keyword">const</span> <span class="keyword">char</span> *domain, async_result_cb cb)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//建立网络连接</span></span><br><span class="line"><span class="keyword">int</span> sockfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (sockfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;create socket failed\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;url:%s\n&quot;</span>, domain);</span><br><span class="line"></span><br><span class="line">set_block(sockfd, <span class="number">0</span>); <span class="comment">//nonblock</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">dest</span>;</span></span><br><span class="line">bzero(&amp;dest, <span class="keyword">sizeof</span>(dest));</span><br><span class="line">dest.sin_family = AF_INET;</span><br><span class="line">dest.sin_port = htons(<span class="number">53</span>);</span><br><span class="line">dest.sin_addr.s_addr = inet_addr(DNS_SVR);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ret = connect(sockfd, (struct sockaddr*)&amp;dest, <span class="keyword">sizeof</span>(dest));</span><br><span class="line"><span class="comment">//printf(&quot;connect :%d\n&quot;, ret);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//准备好对应的DNS协议</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dns_header</span> <span class="title">header</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">dns_create_header(&amp;header);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dns_question</span> <span class="title">question</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">dns_create_question(&amp;question, domain);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//UDP协议，sendto</span></span><br><span class="line"><span class="keyword">char</span> request[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> req_len = dns_build_request(&amp;header, &amp;question, request);</span><br><span class="line"><span class="keyword">int</span> slen = sendto(sockfd, request, req_len, <span class="number">0</span>, (struct sockaddr*)&amp;dest, <span class="keyword">sizeof</span>(struct sockaddr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//fd加入epoll</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ep_arg</span> *<span class="title">eparg</span> =</span> (struct ep_arg*)<span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(struct ep_arg));</span><br><span class="line"><span class="keyword">if</span> (eparg == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">eparg-&gt;sockfd = sockfd;</span><br><span class="line">eparg-&gt;cb = cb;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">ev.data.ptr = eparg;</span><br><span class="line">ev.events = EPOLLIN;</span><br><span class="line"></span><br><span class="line">ret = epoll_ctl(ctx-&gt;epfd, EPOLL_CTL_ADD, sockfd, &amp;ev); </span><br><span class="line"><span class="comment">//printf(&quot; epoll_ctl ADD: sockfd-&gt;%d, ret:%d\n&quot;, sockfd, ret);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="init"><a href="#init" class="headerlink" title="init()"></a>init()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct async_context *<span class="title">dns_async_client_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建epoll</span></span><br><span class="line"><span class="keyword">int</span> epfd = epoll_create(<span class="number">1</span>); </span><br><span class="line"><span class="keyword">if</span> (epfd &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">async_context</span> *<span class="title">ctx</span> =</span> <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(struct async_context));</span><br><span class="line"><span class="keyword">if</span> (ctx == <span class="literal">NULL</span>) &#123;</span><br><span class="line">close(epfd);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">ctx-&gt;epfd = epfd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建线程</span></span><br><span class="line"><span class="keyword">pthread_t</span> thread_id;</span><br><span class="line"><span class="keyword">int</span> ret = pthread_create(&amp;thread_id, <span class="literal">NULL</span>, dns_async_client_callback, ctx);</span><br><span class="line"><span class="keyword">if</span> (ret) &#123;</span><br><span class="line">perror(<span class="string">&quot;pthread_create&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">usleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ctx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="callback"><a href="#callback" class="headerlink" title="callback()"></a>callback()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">dns_async_client_callback</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//拿到上下文</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">async_context</span> *<span class="title">ctx</span> =</span> (struct async_context*)arg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> epfd = ctx-&gt;epfd;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>[<span class="title">ASYNC_CLIENT_NUM</span>] =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> nready = epoll_wait(epfd, events, ASYNC_CLIENT_NUM, <span class="number">-1</span>);<span class="comment">//timeout = -1表示一直阻塞直到有事件触发</span></span><br><span class="line"><span class="keyword">if</span> (nready &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (errno == EINTR || errno == EAGAIN) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nready == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;nready:%d\n&quot;</span>, nready);</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>;i &lt; nready;i ++) &#123;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ep_arg</span> *<span class="title">data</span> =</span> (struct ep_arg*)events[i].data.ptr;</span><br><span class="line"><span class="keyword">int</span> sockfd = data-&gt;sockfd;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buffer[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line"><span class="keyword">size_t</span> addr_len = <span class="keyword">sizeof</span>(struct sockaddr_in);</span><br><span class="line"><span class="keyword">int</span> n = recvfrom(sockfd, buffer, <span class="keyword">sizeof</span>(buffer), <span class="number">0</span>, (struct sockaddr*)&amp;addr, (<span class="keyword">socklen_t</span>*)&amp;addr_len);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dns_item</span> *<span class="title">domain_list</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">            <span class="comment">//解析IP地址，返回的是该域名IP地址的数量</span></span><br><span class="line"><span class="keyword">int</span> count = dns_parse_response(buffer, &amp;domain_list);</span><br><span class="line"></span><br><span class="line">data-&gt;cb(domain_list, count); <span class="comment">//call cb</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//从epoll中移除</span></span><br><span class="line"><span class="keyword">int</span> ret = epoll_ctl(epfd, EPOLL_CTL_DEL, sockfd, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//printf(&quot;epoll_ctl DEL --&gt; sockfd:%d\n&quot;, sockfd);</span></span><br><span class="line"></span><br><span class="line">close(sockfd); <span class="comment">/////</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//释放该域名和IP地址所占的内存</span></span><br><span class="line">dns_async_client_free_domains(domain_list, count);</span><br><span class="line"><span class="built_in">free</span>(data);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="destroy"><a href="#destroy" class="headerlink" title="destroy()"></a>destroy()</h3><ul><li>关闭epfd;</li><li>结束线程，调用pthread_cancel()；</li></ul><h3 id="result-callback"><a href="#result-callback" class="headerlink" title="result_callback()"></a>result_callback()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打印当前的IP地址，IP数量，域名</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dns_async_client_result_callback</span><span class="params">(struct dns_item *<span class="built_in">list</span>, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;count: %d\n&quot;</span>,count);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>;i &lt; count;i ++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;name:%s, ip:%s\n&quot;</span>, <span class="built_in">list</span>[i].domain, <span class="built_in">list</span>[i].ip);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="调试结果"><a href="#调试结果" class="headerlink" title="调试结果"></a>调试结果</h2><p><img src="/2021/05/06/%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82%E6%B1%A0%E6%A1%86%E6%9E%B6%E5%AE%9E%E7%8E%B0/image1.png" alt="image-20210504195351880"></p><p><img src="/2021/05/06/%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82%E6%B1%A0%E6%A1%86%E6%9E%B6%E5%AE%9E%E7%8E%B0/image2.png" alt="image-20210504195423705"></p><p><img src="/2021/05/06/%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82%E6%B1%A0%E6%A1%86%E6%9E%B6%E5%AE%9E%E7%8E%B0/image3.png" alt="image-20210504195440299"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>异步究竟快在哪里？我们在设计的时候，用两个线程处理，主线程只管发送请求，而用另一个线程只管接收请求，并解析返回的数据。如果是同步的情况下，我们在请求DNS服务器的时候，是一请求一返回，也就是说，同步的这种串行执行方式，需要等待结果返回才能进行下一次的请求发送；而相比同步，异步是并行处理，发送一个请求完了以后，不需要等待结果的返回。当然，不仅是DNS协议解析可以这样做，当我们提交业务请求到mysql/redis时也可以用异步commit的方式去实现。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;如何做一个异步请求？&quot;&gt;&lt;a href=&quot;#如何做一个异步请求？&quot; class=&quot;headerlink&quot; title=&quot;如何做一个异步请求？&quot;&gt;&lt;/a&gt;如何做一个异步请求？&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;一个连接还是多个连接？多个连接&lt;/li&gt;
&lt;li&gt;网络IO的基础，发送对应的协议&lt;/li&gt;
&lt;li&gt;既然是多个连接，发送完请求以后，响应没有接收以前，fd存储在哪？ –&amp;gt;fd由epoll进行管理&lt;/li&gt;
&lt;li&gt;请求与响应的数据，不能做到一个线程&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;如何设计？&quot;&gt;&lt;a href=&quot;#如何设计？&quot; class=&quot;headerlink&quot; title=&quot;如何设计？&quot;&gt;&lt;/a&gt;如何设计？&lt;/h2&gt;&lt;h3 id=&quot;封装一组API：&quot;&gt;&lt;a href=&quot;#封装一组API：&quot; class=&quot;headerlink&quot; title=&quot;封装一组API：&quot;&gt;&lt;/a&gt;封装一组API：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;commit:&lt;ul&gt;
&lt;li&gt;建立好网络连接&lt;/li&gt;
&lt;li&gt;组织好对应的协议&lt;/li&gt;
&lt;li&gt;send到对应的服务器&lt;/li&gt;
&lt;li&gt;fd是否可读，fd加入epoll&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;init：异步操作的上下文&lt;ul&gt;
&lt;li&gt;epoll_create&lt;/li&gt;
&lt;li&gt;pthread_create&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;callback:&lt;ul&gt;
&lt;li&gt;epoll_wait(),检测当前fd可读&lt;/li&gt;
&lt;li&gt;recv(fd)，读出所有协议数据，并且解析&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;destroy&lt;ul&gt;
&lt;li&gt;close&lt;/li&gt;
&lt;li&gt;pthread_cancel&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="池化技术" scheme="https://liangxiaocode.github.io/categories/%E6%B1%A0%E5%8C%96%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>用最小堆实现定时器以及时间轮</title>
    <link href="https://liangxiaocode.github.io/2021/04/20/%E6%89%8B%E6%92%95%E5%AE%9A%E6%97%B6%E5%99%A8/"/>
    <id>https://liangxiaocode.github.io/2021/04/20/%E6%89%8B%E6%92%95%E5%AE%9A%E6%97%B6%E5%99%A8/</id>
    <published>2021-04-19T16:00:00.000Z</published>
    <updated>2021-04-22T03:56:47.560Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是定时器"><a href="#什么是定时器" class="headerlink" title="什么是定时器"></a>什么是定时器</h1><p>对于服务端而言，驱动服务端逻辑的事件主要有两个，一个是网络事件，另一个则是我们的定时器事件；并且，在不同框架中，这两种事件有不同的实现方式：</p><ul><li>网络事件和时间事件在一个线程中配合使用。例如nginx、redis;</li><li>网络事件和事件事件在不同的线程中处理。例如skynet;</li></ul><h1 id="定时器的应用场景"><a href="#定时器的应用场景" class="headerlink" title="定时器的应用场景"></a>定时器的应用场景</h1><ul><li>心跳检测</li><li>游戏技能冷却</li><li>倒计时</li><li>其他需要使用超时机制的功能（比如epoll_wait()里的timeout）</li></ul><span id="more"></span><h1 id="什么是最小堆"><a href="#什么是最小堆" class="headerlink" title="什么是最小堆"></a>什么是最小堆</h1><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在介绍最小堆之前，我们先看一下满二叉树和完全二叉树的定义</p><ul><li>满二叉树：所有的层节点数都是该层所能容纳结点的最大数量（满足2^n^;n&gt;=0）</li><li>完全二叉树：假设一个二叉树的深度为h，除了最后一层h层外，其他层的结点数都是该层所能容纳结点的最大数量（满足2^n^;n&gt;=0），且h层的结点都集中在左侧</li></ul><h2 id="最小堆的特征"><a href="#最小堆的特征" class="headerlink" title="最小堆的特征"></a>最小堆的特征</h2><ol><li>是一棵完全二叉树；</li><li>某一个结点的值总是小于等于它的子结点的值；</li><li>堆中每一个结点的子树都是最小堆；</li></ol><h2 id="最小堆的增加操作"><a href="#最小堆的增加操作" class="headerlink" title="最小堆的增加操作"></a>最小堆的增加操作</h2><p>为了满足完全二叉树的定义，往二叉树最高层沿最左侧添加一个结点；然后考虑能够能进行上移操作。什么是上移操作，指的是当我们插入一个结点以后，为了满足最小堆的特征，尤其是特征二，我们需要将插入的接点和其父亲结点交换位置，直到满足特征二位置。</p><h2 id="最小堆的删除操作"><a href="#最小堆的删除操作" class="headerlink" title="最小堆的删除操作"></a>最小堆的删除操作</h2><p>删除操作首先需要查找是否包含这个结点，最小堆的查找效率是O(n);查找到以后，我们需要将其与最后一个结点交换，删除的是最后一个结点。而交换完的结点需要先考虑下降操作，如果操作失败再考虑上移操作，最后删除最后一个结点。</p><h1 id="最小堆举例"><a href="#最小堆举例" class="headerlink" title="最小堆举例"></a>最小堆举例</h1><p><img src="/2021/04/20/%E6%89%8B%E6%92%95%E5%AE%9A%E6%97%B6%E5%99%A8/image1.png" alt="image-20210421190215932"></p><p>我们用一个动态数组来存储它</p><p><img src="/2021/04/20/%E6%89%8B%E6%92%95%E5%AE%9A%E6%97%B6%E5%99%A8/image2.png" alt="image-20210421190536118"></p><h1 id="用最小堆实现一个简单的定时任务"><a href="#用最小堆实现一个简单的定时任务" class="headerlink" title="用最小堆实现一个简单的定时任务"></a>用最小堆实现一个简单的定时任务</h1><h2 id="minheap-h"><a href="#minheap-h" class="headerlink" title="minheap.h"></a>minheap.h</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//minheap.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;//用vector存储每个结点，好处在于可以自动扩容</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;//map是用来根据id来增加、删除结点</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*TimerHandler)</span> <span class="params">(struct TimerNode *node)</span></span>; <span class="comment">//cb函数指针</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TimerNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;<span class="comment">//vector里存储的元素个数-1</span></span><br><span class="line">    <span class="keyword">int</span> id = <span class="number">0</span>;<span class="comment">//每个插入结点的顺序</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> expire = <span class="number">0</span>;<span class="comment">//无符号整型：0~65535，超时时间，多久后触发</span></span><br><span class="line">    TimerHandler cb = <span class="literal">NULL</span>;<span class="comment">//回调函数，出发后执行函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinHeapTimer</span> &#123;</span><span class="comment">//封装一个定时器</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MinHeapTimer() &#123;<span class="comment">//初始化</span></span><br><span class="line">        _heap.clear();</span><br><span class="line">        _map.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Count</span><span class="params">()</span> </span>&#123;<span class="comment">//静态内联函数：所有类共用一个_count</span></span><br><span class="line">        <span class="keyword">return</span> ++_count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">AddTimer</span><span class="params">(<span class="keyword">uint32_t</span> expire, TimerHandler cb)</span></span>;<span class="comment">//添加一个定时任务</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">DelTimer</span><span class="params">(<span class="keyword">int</span> id)</span></span>;<span class="comment">//删除定时器未执行的任务</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ExpireTimer</span><span class="params">()</span></span>;<span class="comment">//测试函数，取最小堆的根结点从vector里pop出去然后调用回调函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">bool</span> _lessThan(<span class="keyword">int</span> lhs, <span class="keyword">int</span> rhs) &#123;<span class="comment">//比较操作，用于上移和下沉操作</span></span><br><span class="line">        <span class="keyword">return</span> _heap[lhs]-&gt;expire &lt; _heap[rhs]-&gt;expire;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> _shiftDown(<span class="keyword">int</span> pos);<span class="comment">//下沉</span></span><br><span class="line">    <span class="keyword">void</span> _shiftUp(<span class="keyword">int</span> pos);<span class="comment">//上移</span></span><br><span class="line">    <span class="keyword">void</span> _delNode(TimerNode *node);<span class="comment">//删除一个定时任务</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;TimerNode*&gt;  _heap;<span class="comment">//vector存储定时任务</span></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, TimerNode*&gt; _map;<span class="comment">//可以说是用map管理每一个定时任务</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> _count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> MinHeapTimer::_count = <span class="number">0</span>;<span class="comment">//_count 初始化</span></span><br></pre></td></tr></table></figure><h2 id="minheap-cpp"><a href="#minheap-cpp" class="headerlink" title="minheap.cpp"></a>minheap.cpp</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//minheap.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;minheap.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取当前时间</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">time_t</span> <span class="title">current_time</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">time_t</span> t;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">gettimeofday(&amp;tv, <span class="literal">NULL</span>);</span><br><span class="line">t = (<span class="keyword">time_t</span>)tv.tv_sec;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加定时器任务</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MinHeapTimer::AddTimer</span><span class="params">(<span class="keyword">uint32_t</span> expire, TimerHandler cb)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int64_t</span> timeout = current_time() + expire;<span class="comment">//当前时间加上传入的延迟实现</span></span><br><span class="line">    TimerNode* node = <span class="keyword">new</span> TimerNode;</span><br><span class="line">    <span class="keyword">int</span> id = Count();<span class="comment">//id = ++ _count;</span></span><br><span class="line">    node-&gt;id = id;</span><br><span class="line">    node-&gt;expire = timeout;</span><br><span class="line">    node-&gt;cb = cb;</span><br><span class="line">    node-&gt;idx = (<span class="keyword">int</span>)_heap.size(); <span class="comment">//idx从0开始然后再push_back()每次加1</span></span><br><span class="line">    _heap.push_back(node); <span class="comment">//加入到动态数组里</span></span><br><span class="line">    _shiftUp((<span class="keyword">int</span>)_heap.size() - <span class="number">1</span>);<span class="comment">//上移操作，实现一个最小堆</span></span><br><span class="line">    _map.insert(<span class="built_in">make_pair</span>(id, node));<span class="comment">//加入到map里方便管理</span></span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除定时器里还未执行的任务</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">MinHeapTimer::DelTimer</span><span class="params">(<span class="keyword">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> iter = _map.find(id);</span><br><span class="line">    <span class="keyword">if</span> (iter == _map.end()) <span class="comment">//删除失败，该任务可能已经执行完毕或这已经被删除</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    _delNode(iter-&gt;second);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除一个定时任务的结点</span></span><br><span class="line"><span class="keyword">void</span> MinHeapTimer::_delNode(TimerNode *node)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> last = (<span class="keyword">int</span>)_heap.size() - <span class="number">1</span>; <span class="comment">//拿到最后一个结点</span></span><br><span class="line">    <span class="keyword">int</span> idx = node-&gt;idx;</span><br><span class="line">    <span class="keyword">if</span> (idx != last) &#123;</span><br><span class="line">        <span class="built_in">std</span>::swap(_heap[idx], _heap[last]); <span class="comment">//交换两个结点</span></span><br><span class="line">        _heap[idx]-&gt;idx = idx;</span><br><span class="line">        <span class="keyword">if</span> (!_shiftDown(idx)) &#123;<span class="comment">//如果下降操作失败，尝试进行上移操作</span></span><br><span class="line">            _shiftUp(idx);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    _heap.pop_back();<span class="comment">//将最后一个结点从vector中删除</span></span><br><span class="line">    _map.erase(node-&gt;id);<span class="comment">//结点从map中删除</span></span><br><span class="line">    <span class="keyword">delete</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试函数，这里做的是</span></span><br><span class="line"><span class="comment">//首先，打印现有vector中的结点信息</span></span><br><span class="line"><span class="comment">//其次，将第一个结点拿出来并执行其cb(回调)函数，传入的参数是该结点本身</span></span><br><span class="line"><span class="comment">//最后，删除拿出来的结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MinHeapTimer::ExpireTimer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (_heap.empty()) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> now = current_time();</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        TimerNode* node = _heap.front();</span><br><span class="line">        <span class="keyword">if</span> (now &lt; node-&gt;expire)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _heap.size();  i++)</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;touch    idx: &quot;</span> &lt;&lt; _heap[i]-&gt;idx </span><br><span class="line">                &lt;&lt; <span class="string">&quot; id: &quot;</span> &lt;&lt; _heap[i]-&gt;id &lt;&lt; <span class="string">&quot; expire: &quot;</span></span><br><span class="line">                &lt;&lt; _heap[i]-&gt;expire &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;cb) &#123;</span><br><span class="line">            node-&gt;cb(node);</span><br><span class="line">        &#125;</span><br><span class="line">        _delNode(node);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!_heap.empty());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下沉操作</span></span><br><span class="line"><span class="keyword">bool</span> MinHeapTimer::_shiftDown(<span class="keyword">int</span> pos)&#123;</span><br><span class="line">    <span class="keyword">int</span> last = (<span class="keyword">int</span>)_heap.size()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> idx = pos;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">2</span> * idx + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> ((left &gt;= last) || (left &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> min = left; <span class="comment">// left child</span></span><br><span class="line">        <span class="keyword">int</span> right = left + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (right &lt; last &amp;&amp; !_lessThan(left, right)) &#123;</span><br><span class="line">            min = right; <span class="comment">// right child</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!_lessThan(min, idx)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::swap(_heap[idx], _heap[min]);</span><br><span class="line">        _heap[idx]-&gt;idx = idx;</span><br><span class="line">        _heap[min]-&gt;idx = min;</span><br><span class="line">        idx = min;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> idx &gt; pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上移操作</span></span><br><span class="line"><span class="keyword">void</span> MinHeapTimer::_shiftUp(<span class="keyword">int</span> pos)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> parent = (pos - <span class="number">1</span>) / <span class="number">2</span>; <span class="comment">// parent node</span></span><br><span class="line">        <span class="keyword">if</span> (parent == pos || !_lessThan(pos, parent)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::swap(_heap[parent], _heap[pos]);</span><br><span class="line">        _heap[parent]-&gt;idx = parent;</span><br><span class="line">        _heap[pos]-&gt;idx = pos;</span><br><span class="line">        pos = parent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//回调函数，每个定时器统一的任务</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_hello</span><span class="params">(TimerNode *te)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;  <span class="string">&quot;hello world time = &quot;</span> &lt;&lt; te-&gt;idx &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; te-&gt;id &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MinHeapTimer mht;<span class="comment">//生成MinHeapTimer 的对象</span></span><br><span class="line">    mht.AddTimer(<span class="number">0</span>, print_hello);<span class="comment">//顺序添加0，1，7，2，9，10，6，3s的定时任务</span></span><br><span class="line">    mht.AddTimer(<span class="number">1000</span>, print_hello);</span><br><span class="line">    mht.AddTimer(<span class="number">7000</span>, print_hello);</span><br><span class="line">    mht.AddTimer(<span class="number">2000</span>, print_hello);</span><br><span class="line">    mht.AddTimer(<span class="number">9000</span>, print_hello);</span><br><span class="line">    mht.AddTimer(<span class="number">10000</span>, print_hello);</span><br><span class="line">    mht.AddTimer(<span class="number">6000</span>, print_hello);</span><br><span class="line">    mht.AddTimer(<span class="number">3000</span>, print_hello);</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        mht.ExpireTimer();<span class="comment">//防止程序退出，我们这里用一个永真的循环,实际上ExpireTimer()只执行一次</span></span><br><span class="line">        usleep(<span class="number">10000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p><img src="/2021/04/20/%E6%89%8B%E6%92%95%E5%AE%9A%E6%97%B6%E5%99%A8/image3.png" alt="image-20210421202907412"></p><p><img src="/2021/04/20/%E6%89%8B%E6%92%95%E5%AE%9A%E6%97%B6%E5%99%A8/image4.png" alt="image-20210421202918252"></p><p>可以看到，我们每次拿出第一个结点，但由于最小堆的性质，第一个结点始终在变化，所以每次打印的id都不是一个顺序变化的。</p><p><strong>然而，如果是在真正的定时任务中，我们在一个vector数组中存储所有连接数，需要每秒去检测vector里元素的状态（是否已经到达超时时间），那么这样我们就需要每秒去遍历所有的连接，因此我们就会做了很多无效的检测。map结构也是这样，事实上map就是基于红黑树实现的。假设这个map结构包含了几万条链接，那么无效加测的数量就会让我们难以接受。考虑一个极端的情况，刚添加进来的结点，下一秒就需要通过遍历取检测它，这是得不偿失的。因此，这里我们考虑用时间轮去检测它，实际上linux内核就是这样做的。</strong></p><h1 id="时间轮"><a href="#时间轮" class="headerlink" title="时间轮"></a>时间轮</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>用一个时钟来通俗地解释一下时间轮的概念：</p><p><img src="/2021/04/20/%E6%89%8B%E6%92%95%E5%AE%9A%E6%97%B6%E5%99%A8/image5.png" alt="image-20210421204622454"></p><ul><li>定义一个数组描述表盘可读: int seconds[60];</li><li>++second_hand%60 每秒钟++second_hand来描述秒针移动，对second_hand%60表示让秒钟永远在[0,59]间移动；</li><li>对于时钟来说，它的时间精度（最小运行单元）是1秒，而在linux内核里时间精度是10ms。</li></ul><h2 id="单层级时间轮"><a href="#单层级时间轮" class="headerlink" title="单层级时间轮"></a>单层级时间轮</h2><p><strong>什么是单层级时间？</strong></p><p>我们假设在这样一个简单的背景下：客户端每5秒发送一个心跳包，服务端若10秒内没收到心跳数据，则清除该连接。然而在实际开发中，若收到了除了心跳包的其他数据，心跳检测也算通过，在这里为了简化流程，只判断心跳包；</p><h3 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h3><ol><li><p>准备一个数组存储连接的数据，那么数组长度应该设置未多少？</p></li><li><p>考虑一秒内添加了多条连接，那么可以参考hash结构处理冲突的方式吗，用一个链表链接起来；</p></li><li><p>回到1中的问题，如果想2中的链表稀疏，可以将数组长度设置大一些；如果想紧凑点，则将数组长度设置小点（但必须大于10）</p></li><li><p>假设我们设置的数组长度为15；那么检测指针的移动可描述为++point%15;</p><p>m%n = m - n ✖ floor(m/n)</p><p>优化：将n替换为2^k^,这里2^k^必须恰好大于n；这样m%2^k^可以转化为m&amp;(2^k^-1);</p><p>因此我们这里选择16(2^4^),那么检测指针移动可以优化为++point&amp;(16-1);</p></li><li><p>考虑到正常情况下5ms发送一个心跳包，服务端10s才检测一次，也就是说假设一个fd发送了在0s时刻和5s时刻都发送了一个心跳包，那么需要在15s的时候检测完毕后才能踢掉连接，也就是说需要一个used++来记录心跳包的发送个数，没检测一次used–,当used == 0时踢掉连接；</p></li></ol><p><img src="/2021/04/20/%E6%89%8B%E6%92%95%E5%AE%9A%E6%97%B6%E5%99%A8/image6.png" alt="image-20210422105020228"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_TIMER ((1&lt;&lt;17)-1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_CONN ((1&lt;&lt;16)-1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">conn_node</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> used;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">&#125; <span class="keyword">conn_node_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">timer_node</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timer_node</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">conn_node</span> *<span class="title">node</span>;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> idx;</span><br><span class="line">&#125; <span class="keyword">timer_node_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为了解决频繁创建内存销毁内存</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">timer_node_t</span> timer_nodes[MAX_TIMER] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">conn_node_t</span> conn_nodes[MAX_CONN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uint32_t</span> t_iter = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uint32_t</span> c_iter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">timer_node_t</span> * <span class="title">get_timer_node</span><span class="params">()</span> </span>&#123; <span class="comment">// 注意：没有检测定时任务数超过 MAX_TIMER 的情况</span></span><br><span class="line">    t_iter++;</span><br><span class="line">    <span class="keyword">while</span> (timer_nodes[t_iter &amp; MAX_TIMER].idx &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        t_iter++;</span><br><span class="line">    &#125;</span><br><span class="line">    timer_nodes[t_iter].idx = t_iter;</span><br><span class="line">    <span class="keyword">return</span> &amp;timer_nodes[t_iter];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//malloc(MAX_CONN*sizeof(struct conn_node))</span></span><br><span class="line"><span class="function"><span class="keyword">conn_node_t</span> * <span class="title">get_conn_node</span><span class="params">()</span> </span>&#123; <span class="comment">// 注意：没有检测连接数超过 MAX_CONN 的情况</span></span><br><span class="line">    c_iter++;</span><br><span class="line">    <span class="keyword">while</span> (conn_nodes[c_iter &amp; MAX_CONN].used &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        c_iter++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;conn_nodes[c_iter];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TW_SIZE 16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXPIRE 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TW_MASK (TW_SIZE - 1)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uint32_t</span> tick = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">link_list</span> &#123;</span></span><br><span class="line"><span class="keyword">timer_node_t</span> head;</span><br><span class="line"><span class="keyword">timer_node_t</span> *tail;</span><br><span class="line">&#125;<span class="keyword">link_list_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送心跳包</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_conn</span><span class="params">(<span class="keyword">link_list_t</span> *tw, <span class="keyword">conn_node_t</span> *cnode, <span class="keyword">int</span> delay)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">link_list_t</span> *<span class="built_in">list</span> = &amp;tw[(tick+EXPIRE+delay) &amp; TW_MASK];</span><br><span class="line">    <span class="keyword">timer_node_t</span> * tnode = get_timer_node();</span><br><span class="line">    cnode-&gt;used++;</span><br><span class="line">    tnode-&gt;node = cnode;</span><br><span class="line">    <span class="built_in">list</span>-&gt;tail-&gt;next = tnode;</span><br><span class="line"><span class="built_in">list</span>-&gt;tail = tnode;</span><br><span class="line">tnode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">link_clear</span><span class="params">(<span class="keyword">link_list_t</span> *<span class="built_in">list</span>)</span> </span>&#123;</span><br><span class="line"><span class="built_in">list</span>-&gt;head.next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">list</span>-&gt;tail = &amp;(<span class="built_in">list</span>-&gt;head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//检测心跳包连接</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check_conn</span><span class="params">(<span class="keyword">link_list_t</span> *tw)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> itick = tick;</span><br><span class="line">    tick++;</span><br><span class="line">    <span class="keyword">link_list_t</span> *<span class="built_in">list</span> = &amp;t w[itick &amp; TW_MASK];</span><br><span class="line">    <span class="keyword">timer_node_t</span> *current = <span class="built_in">list</span>-&gt;head.next;</span><br><span class="line">    <span class="keyword">while</span> (current) &#123;</span><br><span class="line"><span class="keyword">timer_node_t</span> * temp = current;</span><br><span class="line">current = current-&gt;next;</span><br><span class="line">        <span class="keyword">conn_node_t</span> *cn = temp-&gt;node;</span><br><span class="line">        cn-&gt;used--;</span><br><span class="line">        temp-&gt;idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (cn-&gt;used == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;fd:%d kill down\n&quot;</span>, cn-&gt;id);</span><br><span class="line">            temp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fd:%d used:%d\n&quot;</span>, cn-&gt;id, cn-&gt;used);<span class="comment">//打印当前的fd以及还有多少连接数量</span></span><br><span class="line">&#125;</span><br><span class="line">    link_clear(<span class="built_in">list</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">time_t</span> <span class="title">current_time</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">time_t</span> t;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">gettimeofday(&amp;tv, <span class="literal">NULL</span>);</span><br><span class="line">t = (<span class="keyword">time_t</span>)tv.tv_sec;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(timer_nodes, <span class="number">0</span>, MAX_TIMER * <span class="keyword">sizeof</span>(<span class="keyword">timer_node_t</span>));</span><br><span class="line">    <span class="built_in">memset</span>(conn_nodes, <span class="number">0</span>, MAX_CONN * <span class="keyword">sizeof</span>(<span class="keyword">conn_node_t</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// init link list</span></span><br><span class="line">    <span class="keyword">link_list_t</span> tw[TW_SIZE];</span><br><span class="line">    <span class="built_in">memset</span>(tw, <span class="number">0</span>, TW_SIZE * <span class="keyword">sizeof</span>(<span class="keyword">link_list_t</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; TW_SIZE; i++) &#123;</span><br><span class="line">        link_clear(&amp;tw[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该测试起始时间为0秒，所以 delay 不能添加超过10的数。</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">conn_node_t</span> *node = get_conn_node(); </span><br><span class="line">        node-&gt;id = <span class="number">10001</span>;<span class="comment">//相当于fd</span></span><br><span class="line">        add_conn(tw, node, <span class="number">0</span>);<span class="comment">//10s时检测该心跳包</span></span><br><span class="line">        add_conn(tw, node, <span class="number">5</span>);<span class="comment">//15s时检测该心跳包，并剔除该连接</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">conn_node_t</span> *node = get_conn_node();</span><br><span class="line">        node-&gt;id = <span class="number">10002</span>;</span><br><span class="line">        add_conn(tw, node, <span class="number">1</span>);<span class="comment">//11s检测并剔除该连接</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">conn_node_t</span> *node = get_conn_node();</span><br><span class="line">        node-&gt;id = <span class="number">10003</span>;</span><br><span class="line">        add_conn(tw, node, <span class="number">3</span>);<span class="comment">//13s检测并剔除连接</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">time_t</span> start = current_time();<span class="comment">//获取当前时间</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">time_t</span> now = current_time();</span><br><span class="line">        <span class="keyword">if</span> (now - start &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;now-start; i++)</span><br><span class="line">                check_conn(tw);<span class="comment">//每过1scheck一次</span></span><br><span class="line">            start = now;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;check conn tick:%d\n&quot;</span>, tick); <span class="comment">//相当于秒表，每过1s打印一次</span></span><br><span class="line">        &#125;</span><br><span class="line">        usleep(<span class="number">20000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="测试结果-1"><a href="#测试结果-1" class="headerlink" title="测试结果"></a>测试结果</h3><p><img src="/2021/04/20/%E6%89%8B%E6%92%95%E5%AE%9A%E6%97%B6%E5%99%A8/image7.png" alt="image-20210422112356361"></p><p>通过测试结果我们可以看到，与我们的预期一致。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>单层级时间轮只是方便我们去更好地理解多层级时间轮，因为工程中都是用多层级时间轮实现的，并且Linux内核里也是这么实现的。定时器的实现往往也是面试中常问的题目，所以我们需要熟练的掌握定时器的原理，以及它的底层的数据结构是怎样的。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;什么是定时器&quot;&gt;&lt;a href=&quot;#什么是定时器&quot; class=&quot;headerlink&quot; title=&quot;什么是定时器&quot;&gt;&lt;/a&gt;什么是定时器&lt;/h1&gt;&lt;p&gt;对于服务端而言，驱动服务端逻辑的事件主要有两个，一个是网络事件，另一个则是我们的定时器事件；并且，在不同框架中，这两种事件有不同的实现方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;网络事件和时间事件在一个线程中配合使用。例如nginx、redis;&lt;/li&gt;
&lt;li&gt;网络事件和事件事件在不同的线程中处理。例如skynet;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;定时器的应用场景&quot;&gt;&lt;a href=&quot;#定时器的应用场景&quot; class=&quot;headerlink&quot; title=&quot;定时器的应用场景&quot;&gt;&lt;/a&gt;定时器的应用场景&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;心跳检测&lt;/li&gt;
&lt;li&gt;游戏技能冷却&lt;/li&gt;
&lt;li&gt;倒计时&lt;/li&gt;
&lt;li&gt;其他需要使用超时机制的功能（比如epoll_wait()里的timeout）&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="面试常问题" scheme="https://liangxiaocode.github.io/tags/%E9%9D%A2%E8%AF%95%E5%B8%B8%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>手撕一个简单的线程池</title>
    <link href="https://liangxiaocode.github.io/2021/04/16/%E6%89%8B%E6%92%95%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>https://liangxiaocode.github.io/2021/04/16/%E6%89%8B%E6%92%95%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0/</id>
    <published>2021-04-15T16:00:00.000Z</published>
    <updated>2021-05-04T02:55:07.813Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是线程池"><a href="#什么是线程池" class="headerlink" title="什么是线程池"></a>什么是线程池</h1><h2 id="线程池的概念"><a href="#线程池的概念" class="headerlink" title="线程池的概念"></a>线程池的概念</h2><p>线程池就是首先创建一些线程，它们的集合称为线程池。使用线程池能够很好地提升性能，线程池在系统启动的时候就会创建大量空闲的线程，应用程序会将一个个任务放到任务队列里面，当任务队列里有任务的时候，就会启动线程池中的一个线程来执行这个任务，任务结束以后，该线程不会死亡，而是再次返回线程池进入一个空闲的状态，等待下一个任务的到来。</p><h2 id="使用线程池的原因"><a href="#使用线程池的原因" class="headerlink" title="使用线程池的原因"></a>使用线程池的原因</h2><p>多线程运行时，系统不断的启动和关闭新线程，成本会很高，而且会过度消耗系统资源并且会造成线程切换的危险。这时，我们就需要一个线程池来解决了。</p><span id="more"></span><h1 id="线程池的组成"><a href="#线程池的组成" class="headerlink" title="线程池的组成"></a>线程池的组成</h1><p>一般的线程池由三个部分组成：</p><ol><li>任务队列</li><li>执行队列</li><li>管理组件</li></ol><p>我们用一个银行的办业务模式来比喻线程池：</p><ul><li><p>任务队列是线程池提供的一个API，将任务从外面push到任务队列里面，就好比每个前来办业务的人，把这些人用一个取号机链接起来，就形成了一个任务队列，并且每个人所需要办理的业务可能是不一样的。</p></li><li><p>执行队列是线程池里的每一个线程，所有线程也用队列的方式链接起来，而这个接口是不对外开放的，就好比银行里的帮助办业务的柜员，他们处理任务的过程用户是不知道的。</p></li><li><p>管理组件是线程池里最重要的部分，我们也可以认为它就是线程池本身，就好比银行里的大堂经理，他需要知道每一个柜员（线程）的信息，每一个办理业务的人（任务）的信息，同时他还需要拿到互斥锁和条件变量。互斥锁的作用主要是防止多个线程抢占一个资源的，而条件变量的作用是为了防止当某一个线程拿到锁以后，却发现没有任务可以执行，那此时需要先释放这把锁，否则就会造成死锁的情况，直到有任务来会重新拿到这把锁才会把任务继续执行下去。</p></li></ul><h1 id="线程池的实现"><a href="#线程池的实现" class="headerlink" title="线程池的实现"></a>线程池的实现</h1><p>线程池我们可以把它分为三个部分区实现它，分别是：</p><ol><li>抽象化的任务队列、执行队列、管理组件的实现</li><li>链表的实现</li><li>函数接口API的实现</li></ol><h2 id="任务队列、执行队列、管理组件"><a href="#任务队列、执行队列、管理组件" class="headerlink" title="任务队列、执行队列、管理组件"></a>任务队列、执行队列、管理组件</h2><ul><li><p>任务队列</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nTask</span>&#123;</span></span><br><span class="line"><span class="keyword">void</span>(*tast_func)(struct nTast *task);<span class="comment">//执行的具体任务</span></span><br><span class="line">    <span class="keyword">void</span> *user_data;<span class="comment">//用到的这个任务里的信息</span></span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nTask</span> *<span class="title">prev</span>;</span><span class="comment">//前驱结点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nTask</span> *<span class="title">prev</span>;</span><span class="comment">//后继结点</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>执行队列</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nWorker</span>&#123;</span></span><br><span class="line"><span class="keyword">pthread_t</span> threadid;<span class="comment">//线程ID</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">terminate</span>;<span class="comment">//线程的终止条件，这里假设的是terminate = 1时结束线程</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nManager</span> *<span class="title">manager</span>;</span><span class="comment">//每一个线程可以从管理员那里获取任务信息</span></span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nWorker</span> *<span class="title">prev</span>;</span><span class="comment">//前驱结点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nWorker</span> *<span class="title">next</span>;</span><span class="comment">//后继结点</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>管理组件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">nManager</span>&#123;</span></span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> mutex;<span class="comment">//互斥锁</span></span><br><span class="line">    <span class="keyword">pthread_cond_t</span>  cond;<span class="comment">//条件变量</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nWorker</span> *<span class="title">workers</span>;</span><span class="comment">//管理的所有线程</span></span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nTask</span> *<span class="title">tasks</span>;</span><span class="comment">//管理的所有任务</span></span><br><span class="line">&#125;ThreadPool;</span><br></pre></td></tr></table></figure></li></ul><h2 id="链表的实现"><a href="#链表的实现" class="headerlink" title="链表的实现"></a>链表的实现</h2><p>由于我们是在纯C环境下实现线程池，所以链表的实现需要自己封装，如果在C++11标准下，可以用STL容器里已经封装好的list实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我们用宏定义的方法实现链表，这样做的好处是，程序在预编译阶段就会把代码copy过去</span></span><br><span class="line"><span class="comment">//这里我们采用头插法，item是要插入的结点，而list是队列的头结点</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST_INSERT(item,list)do&#123;\</span></span><br><span class="line">item-&gt;prev = <span class="literal">NULL</span>;\</span><br><span class="line">item-&gt;next = <span class="built_in">list</span>;\</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">list</span> != <span class="literal">NULL</span>) <span class="built_in">list</span>-&gt;prev = item;\</span><br><span class="line"><span class="built_in">list</span> = item;\</span><br><span class="line">&#125;<span class="keyword">while</span>(<span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST_REMOVE(item,list)do&#123;\</span></span><br><span class="line">    <span class="keyword">if</span>(item-&gt;prev != <span class="literal">NULL</span>) item-&gt;prev-&gt;next = item-&gt;next;\</span><br><span class="line"><span class="keyword">if</span>(item-&gt;next != <span class="literal">NULL</span>) item-&gt;next-&gt;prev = item-&gt;prev;\</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">list</span> == item) <span class="built_in">list</span> = item-&gt;next;\</span><br><span class="line">item-&gt;next = item-&gt;prev = <span class="literal">NULL</span>;\</span><br><span class="line">&#125;<span class="keyword">while</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="函数接口API的实现"><a href="#函数接口API的实现" class="headerlink" title="函数接口API的实现"></a>函数接口API的实现</h2><p>这里我们一共要实现四个函数，其中有三个是需要能够让外面调用的。</p><ol><li><p>线程池的创建，这个接口是需要外界能够使用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nThreadPoolCreate</span><span class="params">(ThreadPool *pool,<span class="keyword">int</span> numworkers)</span></span>&#123; <span class="comment">//pool是我们的线程池，而numworkers是线程的数量</span></span><br><span class="line"><span class="keyword">if</span>(pool == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(numworkers &lt; <span class="number">1</span>) numworkers = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(pool,<span class="number">0</span>,<span class="keyword">sizeof</span>(ThreadPool));<span class="comment">//在内存上初始化为0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">pthread_cond_t</span> blank_cond = PTHREAD_COND_INITIALIZER;<span class="comment">//对pthread_cond_t 的对象初始化，并赋值给pool-&gt;cond</span></span><br><span class="line"><span class="built_in">memcpy</span>(&amp;pool-&gt;cond, &amp;blank_cond, <span class="keyword">sizeof</span>(<span class="keyword">pthread_cond_t</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> blank_mutex = PTHREAD_MUTEX_INITIALIZER;<span class="comment">//对pthread_mutex_t 的对象初始化，并赋值给pool-&gt;mutex</span></span><br><span class="line"><span class="built_in">memcpy</span>(&amp;pool-&gt;mutex, &amp;blank_mutex, <span class="keyword">sizeof</span>(<span class="keyword">pthread_mutex_t</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>;i &lt; numWorkers;i ++) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nWorker</span> *<span class="title">worker</span> =</span> (struct nWorker*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct nWorker));</span><br><span class="line"><span class="keyword">if</span> (worker == <span class="literal">NULL</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;malloc&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(worker, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct nWorker));</span><br><span class="line">worker-&gt;manager = pool; <span class="comment">//表示该worker在该线程池里面</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ret = pthread_create(&amp;worker-&gt;threadid, <span class="literal">NULL</span>, nThreadPoolCallback, worker);<span class="comment">//创建一个线程</span></span><br><span class="line"><span class="keyword">if</span> (ret) &#123;</span><br><span class="line">perror(<span class="string">&quot;pthread_create&quot;</span>);</span><br><span class="line"><span class="built_in">free</span>(worker);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LIST_INSERT(worker, pool-&gt;workers);<span class="comment">//将该执行线程加入到执行队列里面去</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将任务加入到任务队列里面的函数，这个API也是要让外面能够调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nThreadPoolPushTask</span><span class="params">(ThreadPool *pool, struct nTask *task)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line">pthread_mutex_lock(&amp;pool-&gt;mutex);<span class="comment">//主线程加锁，避免在与其他线程共用一个tast资源的时候发生冲突</span></span><br><span class="line"></span><br><span class="line">LIST_INSERT(task, pool-&gt;tasks);</span><br><span class="line"></span><br><span class="line">pthread_cond_signal(&amp;pool-&gt;cond);<span class="comment">//唤醒一个线程</span></span><br><span class="line"></span><br><span class="line">pthread_mutex_unlock(&amp;pool-&gt;mutex);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>callback函数，每一个线程该处理的任务，处理callback != task</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">nThreadPoolCallback</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nWorker</span> *<span class="title">worker</span> =</span> (struct nWorker*)arg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">pthread_mutex_lock(&amp;worker-&gt;manager-&gt;mutex);<span class="comment">//此线程拿到mutex</span></span><br><span class="line"><span class="keyword">while</span> (worker-&gt;manager-&gt;tasks == <span class="literal">NULL</span>) &#123;<span class="comment">//现在该线程中没有任务，那么就需要释放这把锁。</span></span><br><span class="line"><span class="keyword">if</span> (worker-&gt;<span class="built_in">terminate</span>) <span class="keyword">break</span>;<span class="comment">//terminate = 1时表示线程池已经销毁</span></span><br><span class="line">pthread_cond_wait(&amp;worker-&gt;manager-&gt;cond, &amp;worker-&gt;manager-&gt;mutex);</span><br><span class="line">            <span class="comment">//pthread_cond_wait 条件变量，此线程在这里等待有任务的到来</span></span><br><span class="line"><span class="comment">//可以分解为三个步骤：1、释放互斥锁 2、条件等待，线程挂起 3、再次拿到这把锁</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (worker-&gt;<span class="built_in">terminate</span>) &#123;<span class="comment">//解锁 跳出循环</span></span><br><span class="line">pthread_mutex_unlock(&amp;worker-&gt;manager-&gt;mutex);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nTask</span> *<span class="title">task</span> =</span> worker-&gt;manager-&gt;tasks; <span class="comment">//从任务队列里拿出最头部的任务</span></span><br><span class="line">LIST_REMOVE(task, worker-&gt;manager-&gt;tasks); <span class="comment">//移除结点</span></span><br><span class="line"></span><br><span class="line">pthread_mutex_unlock(&amp;worker-&gt;manager-&gt;mutex);</span><br><span class="line"></span><br><span class="line">task-&gt;task_func(task);<span class="comment">//去执行相应的任务</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(worker);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>销毁线程池，这个API也是需要能够让对方调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nThreadPoolDestory</span><span class="params">(ThreadPool *pool, <span class="keyword">int</span> nWorker)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nWorker</span> *<span class="title">worker</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (worker = pool-&gt;workers;worker != <span class="literal">NULL</span>;worker = worker-&gt;next) &#123;</span><br><span class="line">worker-&gt;<span class="built_in">terminate</span> = <span class="number">1</span>; <span class="comment">//terminate 置1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pthread_mutex_lock(&amp;pool-&gt;mutex);</span><br><span class="line"></span><br><span class="line">pthread_cond_broadcast(&amp;pool-&gt;cond);<span class="comment">//唤醒所有等待的线程继续向下执行，此时的terminate = 1就会跳出内层、外层循环</span></span><br><span class="line"></span><br><span class="line">pthread_mutex_unlock(&amp;pool-&gt;mutex);</span><br><span class="line"></span><br><span class="line">pool-&gt;workers = <span class="literal">NULL</span>;<span class="comment">//释放所有线程后，头结点置为空</span></span><br><span class="line">pool-&gt;tasks = <span class="literal">NULL</span>; <span class="comment">//所有任务结束后，头结点置为空</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>写到这，一个简单的线程池的基本接口就差不多了，具体的调试代码放在TestCode里面。</p><h1 id="线程池的两个思考题"><a href="#线程池的两个思考题" class="headerlink" title="线程池的两个思考题"></a>线程池的两个思考题</h1><h2 id="1-多线程共用fd，如何避免多线程使用的脏数据？"><a href="#1-多线程共用fd，如何避免多线程使用的脏数据？" class="headerlink" title="1. 多线程共用fd，如何避免多线程使用的脏数据？"></a>1. 多线程共用fd，如何避免多线程使用的脏数据？</h2><h3 id="什么是共用fd"><a href="#什么是共用fd" class="headerlink" title="什么是共用fd?"></a>什么是共用fd?</h3><p>​    共用 fd的意思简单的说就是有两个以上的线程对一个fd进行处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读写直接放到一个线程池里面</span></span><br><span class="line"><span class="comment">//伪代码</span></span><br><span class="line">task = fd;</span><br><span class="line">push_tasks(task);</span><br></pre></td></tr></table></figure><p>在网络IO中，我们要把读写的操作都放到一个线程池的任务队列里进行处理，那么我们可以通过传fd到任务队列里，每一个线程在对这个fd进行操作。</p><h3 id="为什么会造成共用fd"><a href="#为什么会造成共用fd" class="headerlink" title="为什么会造成共用fd?"></a>为什么会造成共用fd?</h3><p>这个问题很好理解，就是当客户端发送一帧数据交给服务器处理的时候，服务器把该读写任务抛给线程池里的一个线程去处理，但是，紧接着客户端又发送一帧数据，由于我们传入给任务队列里的是fd，所以另一个线程同样会对此fd进行操作，所以就会造成共用fd的现象，同时会造成fd里有脏数据的可能。</p><h3 id="如何避免多线程使用的脏数据？"><a href="#如何避免多线程使用的脏数据？" class="headerlink" title="如何避免多线程使用的脏数据？"></a>如何避免多线程使用的脏数据？</h3><p>答：加入了线程池后，将fd从epoll里移除。</p><h2 id="2-线程池的放缩策略，如何做比较好？"><a href="#2-线程池的放缩策略，如何做比较好？" class="headerlink" title="2. 线程池的放缩策略，如何做比较好？"></a>2. 线程池的放缩策略，如何做比较好？</h2><p>答：做一个创建线程数量的上限和下限。就是说当任务数量多的时候增加线程数量，当任务数量少的时候减少线程数量。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;什么是线程池&quot;&gt;&lt;a href=&quot;#什么是线程池&quot; class=&quot;headerlink&quot; title=&quot;什么是线程池&quot;&gt;&lt;/a&gt;什么是线程池&lt;/h1&gt;&lt;h2 id=&quot;线程池的概念&quot;&gt;&lt;a href=&quot;#线程池的概念&quot; class=&quot;headerlink&quot; title=&quot;线程池的概念&quot;&gt;&lt;/a&gt;线程池的概念&lt;/h2&gt;&lt;p&gt;线程池就是首先创建一些线程，它们的集合称为线程池。使用线程池能够很好地提升性能，线程池在系统启动的时候就会创建大量空闲的线程，应用程序会将一个个任务放到任务队列里面，当任务队列里有任务的时候，就会启动线程池中的一个线程来执行这个任务，任务结束以后，该线程不会死亡，而是再次返回线程池进入一个空闲的状态，等待下一个任务的到来。&lt;/p&gt;
&lt;h2 id=&quot;使用线程池的原因&quot;&gt;&lt;a href=&quot;#使用线程池的原因&quot; class=&quot;headerlink&quot; title=&quot;使用线程池的原因&quot;&gt;&lt;/a&gt;使用线程池的原因&lt;/h2&gt;&lt;p&gt;多线程运行时，系统不断的启动和关闭新线程，成本会很高，而且会过度消耗系统资源并且会造成线程切换的危险。这时，我们就需要一个线程池来解决了。&lt;/p&gt;</summary>
    
    
    
    <category term="池化技术" scheme="https://liangxiaocode.github.io/categories/%E6%B1%A0%E5%8C%96%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>posix API与网络协议栈</title>
    <link href="https://liangxiaocode.github.io/2021/04/14/posix-API%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88/"/>
    <id>https://liangxiaocode.github.io/2021/04/14/posix-API%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88/</id>
    <published>2021-04-13T16:00:00.000Z</published>
    <updated>2021-04-15T03:22:16.879Z</updated>
    
    <content type="html"><![CDATA[<h1 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h1><ul><li>fd = socket();</li><li>bind(); fd –&gt; IP/port</li><li>listen(fd,backlog);</li><li>clientfd = accept(fd,addr,addrlen);</li><li>recv();</li><li>send();</li><li>close();</li></ul><h1 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h1><ul><li>socket()</li><li>bind(); optional</li><li>connect();</li><li>send();</li><li>recv();</li><li>close();</li></ul><span id="more"></span><h1 id="网络编程流程"><a href="#网络编程流程" class="headerlink" title="网络编程流程"></a>网络编程流程</h1><p><img src="/2021/04/14/posix-API%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88/image1.png" alt="image-20210414113709591"></p><h1 id="面试中协议栈常问的点"><a href="#面试中协议栈常问的点" class="headerlink" title="面试中协议栈常问的点"></a>面试中协议栈常问的点</h1><ol><li>TCP三次握手过程？</li><li>TCP四次挥手过程？</li><li>为什么建立连接需要三次握手，而断开连接需要四次挥手？</li><li>大量TIME_WAIT和CLOSE_WAIT出现的原因以及解决办法？</li><li>超时重传和快速重传？</li><li>TCP首部长度，有哪些字段？</li><li>TCP在listen时的参数backlog的意义？</li><li>accept发生在三次握手的哪一步？</li><li>三次握手过程中有哪些不安全性？</li><li>TCP和UDP的区别？</li></ol><h2 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h2><ul><li>建立连接：UDP不需要建立连接，直接调用sendto()就可以给服务端发送数据，不管对方收没收到。而connet()只是确定从客户端到服务器这条链路是否是通的。而TCP在发送数据之前一定要调用connect()，这样才能让服务器端进入一个特定的状态。</li><li>数据传输：TCP提供无差错的、不丢失的、不重复的且顺序到达的数据，而UDP尽最大努力交付，不保证可靠传输；TCP面向字节流，而UDP面向报文；UDP没有流量控制和拥塞控制，所以出现网络拥塞的情况时不会使数据发送速率降低；TCP只支持点对点通信，而UDP支持一对一，一对多，多对一，多对多通信；</li><li>数据报文：TCP首部开销20字节；UDP首部开销只有8个字节；</li></ul><h2 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h2><p>过程：客户端在应用程序调用connect()，将IP地址和端拷贝到协议栈力，协议栈准备一个syn的包，并将TCP的头syn位置1，然后将syn的包发送给服务端。服务端收到数据以后进入一个listen()的状态并返回一个ack，这个ack = seq+1，此时在半连接(SYN)队列里保存客户端的信息。客户端收到syn,ack并发送syn和ack，此时客户端进入Established的状态，服务端收到ACK后也进入Established的状态，并将半连接队列里的结点直接拿到全连接队列里，注意这里不是拷贝。再调用accept()，如果是阻塞状态，那么会一直等待全连接队列里有数据，如果是非阻塞，一旦全连接队列里没有数据，就会返回-1。<strong>三次握手的过程是发生在客户端调用connect()后，协议栈被动实现的过程。它既不是发生在listen()里面，也不是发生在accept()里面。</strong></p><p><img src="/2021/04/14/posix-API%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88/image2.png" alt="image-20210414125144212"></p><p><img src="/2021/04/14/posix-API%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88/image3.png" alt="image-20210414125235782"></p><p>存在的小问题：</p><ul><li>通过什么找到半连接队列里对应的客户端的结点：五元组（sip,dip,sport,dport,proto）；</li><li>结点（tcp控制块）的生命周期：一直到close()为止；</li></ul><h2 id="TCP是如何保证顺序的？"><a href="#TCP是如何保证顺序的？" class="headerlink" title="TCP是如何保证顺序的？"></a>TCP是如何保证顺序的？</h2><ul><li>超时重传：TCP有自己的一套超时重传机制。即发送主机每次发送数据的时候，TCP就给每个数据包分配一个序列号并且在特定时间内等待接收主机对分配的这个序列号进行确认，如果超过该时间还没收到接收主机的确认，则发送主机会重传此数据，这就是超时重传。但是接收主机并不能保证收到的数据一定是顺序的，而是根据序列号来检测对方发送的数据是否有丢失或者乱序，接收主机一旦收到已经顺序化的数据，那么它就将这些数据按正确的顺序重组（重排）成数据流并传递到应用层进行处理。</li><li>快速重传：跳过多少个包马上重传，是在KCP协议里用到的。发送端发送了1,2,3,4,5几个包，然后收到远端的ACK: 1, 3, 4, 5，当收到ACK3时，KCP知道2被跳过1次，收到ACK4时，知道2被跳过了2次，此时可以认为2号丢失，不用等超时，直接重传2号包，大大改善了丢包时的传输速度。 </li></ul><h2 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h2><p>过程：应用程序调用close(),协议栈会在原有fd的基础上准备一帧带有fin=1的包发送给服务端，客户端进入fin_wait_1的状态；服务端收到客户端的fin包，发送ACK进入close_wait()的状态，关闭读通道，客户端收到fin应答，进入fin_wait_2的状态；服务端调用close()，发送一个fin包给客户端，进入一个last_ack状态；客户端收到fin,发ACK的包，进入time_wait状态，时长位2msl;服务端收到ACK后进入closed状态，读写通道全部关闭；客户端从time_wait状态进入closed状态后把读通道关闭。</p><p><img src="/2021/04/14/posix-API%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88/image2.png" alt="image-20210414125144212"></p><p><img src="/2021/04/14/posix-API%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88/image4.png" alt="image-20210414160125285"></p><h2 id="大量time-wait和close-wait的原因以及解决方法"><a href="#大量time-wait和close-wait的原因以及解决方法" class="headerlink" title="大量time_wait和close_wait的原因以及解决方法"></a>大量time_wait和close_wait的原因以及解决方法</h2><ul><li><p>大量的time_wait</p><ul><li>存在的原因<ol><li>大量短链接的存在。会大量消耗client机器的端口，端口上限只有65535个，端口被耗尽了，后续就无法发起新的连接了。</li><li>time_wait的状态主要是为了保证ACK重发和丢弃延迟数据。如果主动关闭方不进入TIME_WAIT，那么主动关闭方在发送完ACK就走了的话，如果最后发送的ACK在路由过程中丢掉了，最后没能到被动关闭方，这个时候被动关闭方没收到自己FIN的ACK就不能关闭连接，接着被动关闭方会超时重发FIN包，但是这个时候已经没有对端会给该FIN回ACK，被动关闭方就无法正常关闭连接了，所以主动关闭方需要进入TIME_WAIT以便能够重发丢掉的被动关闭方FIN的ACK。</li></ol></li><li>解决方法<ol><li>允许time_wait状态的socket被重用。setsockopt = reuse。</li><li>缩减time_wait时间，可以设置为1MSL。（默认是2MSL = 4mins）。</li></ol></li></ul></li><li><p>大量close_wait</p><ul><li><p>存在的原因</p><p>close_wait存在的原因只有一种情况，就是对方发送FIN包后，服务端没有进一步发送ACK来确认，换句话说就是在对方关闭连接后，程序里没有检测到，或者程序里本身就已经忘了需要调用close()，于是这个资源就一直被占用着。</p></li><li><p>解决方法</p><ol><li>检查业务逻辑代码，尽快修改程序里的bug，比较好的做法是将recv() = 0返回的业务逻辑处理抛给另外一个线程实现。</li></ol></li></ul></li></ul><h2 id="accept发生在三次握手的哪个阶段"><a href="#accept发生在三次握手的哪个阶段" class="headerlink" title="accept发生在三次握手的哪个阶段"></a>accept发生在三次握手的哪个阶段</h2><p>accept()是发生在三次握手完成以后，三次握手完成以后，TCP连接会加入全连接队列，在调用accept()会从全连接队列里返回一个连接，这时的fd就是clientfd，如果队列为空，那么就会阻塞。</p><h2 id="TCP首部有哪些字段"><a href="#TCP首部有哪些字段" class="headerlink" title="TCP首部有哪些字段"></a>TCP首部有哪些字段</h2><p><img src="/2021/04/14/posix-API%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88/image5.png" alt="image-20210415103253036"></p><h2 id="TCP在listen时的参数backlog的意义"><a href="#TCP在listen时的参数backlog的意义" class="headerlink" title="TCP在listen时的参数backlog的意义"></a>TCP在listen时的参数backlog的意义</h2><p>这里有两个说法：</p><ol><li>在linux系统中，指的是全连接队列的上限。</li><li>而在unix或者mac系统中，指的是全连接队列与半连接队列之和的上限。</li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;服务端&quot;&gt;&lt;a href=&quot;#服务端&quot; class=&quot;headerlink&quot; title=&quot;服务端&quot;&gt;&lt;/a&gt;服务端&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;fd = socket();&lt;/li&gt;
&lt;li&gt;bind(); fd –&amp;gt; IP/port&lt;/li&gt;
&lt;li&gt;listen(fd,backlog);&lt;/li&gt;
&lt;li&gt;clientfd = accept(fd,addr,addrlen);&lt;/li&gt;
&lt;li&gt;recv();&lt;/li&gt;
&lt;li&gt;send();&lt;/li&gt;
&lt;li&gt;close();&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;客户端&quot;&gt;&lt;a href=&quot;#客户端&quot; class=&quot;headerlink&quot; title=&quot;客户端&quot;&gt;&lt;/a&gt;客户端&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;socket()&lt;/li&gt;
&lt;li&gt;bind(); optional&lt;/li&gt;
&lt;li&gt;connect();&lt;/li&gt;
&lt;li&gt;send();&lt;/li&gt;
&lt;li&gt;recv();&lt;/li&gt;
&lt;li&gt;close();&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="网络编程" scheme="https://liangxiaocode.github.io/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="面试常问题" scheme="https://liangxiaocode.github.io/tags/%E9%9D%A2%E8%AF%95%E5%B8%B8%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>网络I/O多路复用之epoll,select</title>
    <link href="https://liangxiaocode.github.io/2021/04/05/TCP%E6%9C%8D%E5%8A%A1%E5%99%A8epoll%E7%9A%84%E5%A4%9A%E7%A7%8D%E5%AE%9E%E7%8E%B0/"/>
    <id>https://liangxiaocode.github.io/2021/04/05/TCP%E6%9C%8D%E5%8A%A1%E5%99%A8epoll%E7%9A%84%E5%A4%9A%E7%A7%8D%E5%AE%9E%E7%8E%B0/</id>
    <published>2021-04-04T16:00:00.000Z</published>
    <updated>2021-04-09T01:56:46.154Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网络IO"><a href="#网络IO" class="headerlink" title="网络IO"></a>网络IO</h1><p>网络I/O会涉及两个系统对象，一个是用户调用IO的进程或线程（即应用程序），另一个是内核空间的内核系统。比如当发生IO操作read时，它会经历两个阶段：</p><ul><li>等待数据准备就绪</li><li>将数据从内核拷贝到进程或者线程中</li></ul><p>因为在以上两个阶段各有不同的情况，所以出现了多种网络IO模型。本文主要是介绍多路复用IO之epoll的实现以及与select的对比。</p><h1 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h1><p>IO多路复用(multiplexing)的本质是通过系统内核缓冲IO数据，让单个process可以监听多个文件描述符，当某个描述符就绪时（一般是读就绪或写就绪），就能通知应用程序进行相应的读操作或写操作。我们以读操作为例，看一下select API是如何工作的：</p><p><img src="/2021/04/05/TCP%E6%9C%8D%E5%8A%A1%E5%99%A8epoll%E7%9A%84%E5%A4%9A%E7%A7%8D%E5%AE%9E%E7%8E%B0/image1.png" alt="image-20210405111318568"></p><p>当用户调用了select API，那么整个进程就会阻塞，系统就会从用户态进入内核态，Kernel就会监听所有select负责的socket，当任何一个socket中的数据就绪时，select就会返回。用户进程再调用read API，将数据从Kernel拷贝到用户进程。</p><p>从上图可以看出，实时上，我们进行了两个系统调用（select和read），而阻塞IO（blocking IO）事实上只进行了一次系统调用（read），但是使用select的好处是，在一个线程内，它可以监听所有socket的IO请求。当用户可以注册多个socket，可以通过不断地调用select读取被激活的socket，就能达到在一个线程里处理同时处理多个IO请求的目的。</p><span id="more"></span><h1 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h1><p>我们先看一下select接口原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> maxfds, fd_set *readfds, fd_set *writefds,fd_set *exceptfds,struct timeval *timeout)</span></span>;</span><br><span class="line">FD_ZERO(fd_set *fds);</span><br><span class="line">FD_SET(<span class="keyword">int</span> fd,fd_set *fds);</span><br><span class="line">FD_ISSET(<span class="keyword">int</span> fd,fd_set *fds);</span><br><span class="line">FD_CLR(<span class="keyword">int</span> fd,fd_set *fds);</span><br></pre></td></tr></table></figure><h2 id="函数参数说明"><a href="#函数参数说明" class="headerlink" title="函数参数说明"></a>函数参数说明</h2><ul><li>int maxfds: 指定待测试的文件描述字个数，它的值一般是待测试的最大描述字加1；</li><li>fd_set: 该类型可以简单的理解为按bit位标记句柄的队列，例如要在某fd_set中标记一个值为16的句柄，则该fd_set的第16个bit位被标记为1.具体的位置、验证可使用FD_SET、FD_ISSET等宏实现。中间的三个参数指定我们要让内核测试读、写以及异常条件的文件描述符集合。<strong>如果输入的readfds标记了16号句柄，则select()调用将检测16号句柄是否可读，从而判断是否有“可读”事件的发生。</strong>作为输入参数，readfds,writefds和exceptfds应该标记所有需要探测的“可读事件”、“可写事件”、“异常事件”的句柄（使用FD_SET标记）。作为输出参数，readfds、writefds、exceptfds中保存了select()捕捉到的所有事件的句柄值。程序员需要检查所有的标记位（使用FD_ISSET()检查），来确定是哪些句柄发生了事件。</li><li>struct timeval timeout: 等待超时的时间，若以NULL传入，就是直接将select置于阻塞状态，一定要等到所监听的某个文件描述符发生变化为止；若等于0，select就变成非阻塞函数，即不管有没有文件描述的变化都返回，有变化就返回正值，没变化就返回0；若大于0，则select会在该timeout内阻塞，直到有描述符的变化，即有事件到来，超时都没有也一定会返回，没变化就会返回0；</li></ul><h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><ul><li>负数：select出错；</li><li>0：等待超时，没有文件描述符的变化，也就是没有我们想要关心的事件；</li><li>正数：有文件描述符的变化，有事件到来；</li></ul><h2 id="操作fd-set的宏"><a href="#操作fd-set的宏" class="headerlink" title="操作fd_set的宏"></a>操作fd_set的宏</h2><ul><li>FD_ZERO: 清空fd_set集合；</li><li>FD_SET: 将一个文件描述符的对象添加到集合中；</li><li>FD_ISSET: 判断一下当前socketfd是否可读，即测试一下网络上是否有数据；</li><li>FD_CLR：用来清除一个文件描述符；</li></ul><h2 id="select模型"><a href="#select模型" class="headerlink" title="select模型"></a>select模型</h2><p>select模型是一种“事件驱动模型”，这种模型的特征在于每一个执行周期都会探测一次或一组事件，一个特定的事件会触发某个特定的相应。所以如果select()发现某句柄捕捉到了“可读事件”，服务器程序应及时做recv()操作，并根据接收到的数据准备好待发送的数据，并将对应的句柄值加入writefds，准备下一次“可写事件”的select()探测。同样，如果select()发现某句柄捕捉到“可写事件”，则程序应该及时做send()操作，并准备好下一次的“可读事件”探测准备。</p><h2 id="select模型的优点以及存在的问题"><a href="#select模型的优点以及存在的问题" class="headerlink" title="select模型的优点以及存在的问题"></a>select模型的优点以及存在的问题</h2><ul><li>优点<ul><li>该模型只用单线程（进程）执行，占用资源少，不会消耗太多CPU；</li><li>能同时为多客户端提供服务，如果试图建立一个简单的事件驱动服务处程序，这个模型有一定参考价值；</li></ul></li><li>存在的问题<ul><li>当需要探测的句柄值较大时，select()接口本身需要消耗大量时间来轮询各个句柄。</li><li>该模型会把事件探测和事件响应夹杂在一起（写在一个while(1)里面），一旦事件响应的执行体庞大，则对整个模型是灾难性的后果。</li></ul></li></ul><h2 id="select详解以及例子"><a href="#select详解以及例子" class="headerlink" title="select详解以及例子"></a>select详解以及例子</h2><p><a href="https://blog.csdn.net/a445849497/article/details/80512853?spm=1001.2014.3001.5501">https://blog.csdn.net/a445849497/article/details/80512853?spm=1001.2014.3001.5501</a></p><h1 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h1><p>epoll在Linux2.6内核正式提出，一般来说，为处理TCP的请求，采用的一线程一连接的方式。然而，当出现高并发场景时，即有几十万甚至是几百万的客户端与一个服务器进行连接时，这种多线程的模型与epoll相比就差很远了。并且在高并发的场景，随着文件描述符的增长，相比select、poll线性复杂度的模型，epoll的时间复杂度为O(1)，epoll有着更好的可扩展性。</p><table><thead><tr><th>Number of File Descriptors</th><th>Poll() CPU time</th><th>select() CPU time</th><th>epoll() CPU time</th></tr></thead><tbody><tr><td>10</td><td>0.61</td><td>0.73</td><td>0.41</td></tr><tr><td>100</td><td>2.9</td><td>3</td><td>0.42</td></tr><tr><td>1000</td><td>35</td><td>35</td><td>0.53</td></tr><tr><td>10000</td><td>990</td><td>930</td><td>0.66</td></tr></tbody></table><p>查看用户能注册到的epoll实例的最大文件描述符数量。</p><p><img src="/2021/04/05/TCP%E6%9C%8D%E5%8A%A1%E5%99%A8epoll%E7%9A%84%E5%A4%9A%E7%A7%8D%E5%AE%9E%E7%8E%B0/image2.png" alt="image-20210406112457044"></p><p>epoll接口原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd,<span class="keyword">int</span> op,<span class="keyword">int</span> fd,struct epoll_event *event)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd,struct epoll_event *event,<span class="keyword">int</span> maxevents,<span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="函数参数说明-1"><a href="#函数参数说明-1" class="headerlink" title="函数参数说明"></a>函数参数说明</h2><ul><li><p>epoll_create: 创建一个epoll句柄，参数size表明要监听的描述符的数量。调用成功时返回一个epoll句柄描述符，失败返回-1。要知道在Linux2.6内核之后参数size就只有0和大于0的区别，即epoll_create(1)和epoll_create(1024)是没有区别的，也就是说我们只需要创建出这样一个epoll句柄描述符来管理需要监听的描述符就行了；</p></li><li><p>epoll_ctl:在内核的红黑树上注册要监听的描述符类型；</p><ul><li>int epfd:epoll句柄；</li><li>int op:注册事件的类型：<ul><li>EPOLL_CTL_ADD:注册新的文件描述符fd到epfd中；</li><li>EPOLL_CTL_MOD:修改已注册的文件描述符fd的监听事件；</li><li>EPOLL_CTL_DEL:从epfd中删除一个fd;</li></ul></li><li>int fd:要监听的文件描述符;</li><li>struct epoll_event:要监听的事件；</li></ul></li><li><p>epoll_wait:函数等待监听事件的就绪，成功时就返回就绪的事件数目，失败就返回-1，等到超时就返回0；</p><ul><li>int epfd:epoll句柄；</li><li>struct epoll_event *event:表示从内核中得到的已经就绪的事件列表，这个就绪的事件存储在rdllist双向链表中。</li><li>int maxevents:告诉内核events的大小；</li><li>int timeout:与select中的timeout类似，若timeout = -1时，表示超时等待时间不确定，也有说法是永久阻塞。即有事件到来才返回，没有就一直阻塞；</li></ul></li><li><p>struct epoll_event中的events可以是以下几个宏的集合：</p><ul><li>EPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；</li><li>EPOLLOUT：表示对应的文件描述符可以写；</li><li>EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；</li><li>EPOLLERR：表示对应的文件描述符发生错误；</li><li>EPOLLHUP：表示对应的文件描述符被挂断；</li><li>EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的；</li><li>EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里；</li></ul></li></ul><h2 id="关于EPOLL的触发方式"><a href="#关于EPOLL的触发方式" class="headerlink" title="关于EPOLL的触发方式"></a>关于EPOLL的触发方式</h2><ul><li>水平触发（EPOLLLT）：默认的触发模式，只要有数据没有处理就会一直通知应用程序处理该事件。</li><li>边沿触发（EPOLLET）：仅当状态发生变化的时候才获得通知，所谓状态变化并不包括缓冲区中未处理的数据，也就是说，当采用ET模式，当我们一次recv获取的buffer的大小小于发送数据的大小的时候，那么会有一部分数据再也得不到通知。</li></ul><h2 id="关于两种触发方式的应用场景"><a href="#关于两种触发方式的应用场景" class="headerlink" title="关于两种触发方式的应用场景"></a>关于两种触发方式的应用场景</h2><p>我们假设在ET边沿触发的具体recv()操作前加一个while(1)的循环，即：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">int</span> ret = recv(clientfd,buffer,<span class="number">5</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直到返回-1，即没有数据读了才退出。其实这种循环读+ET触发的方式与LT+一次性读的方式一样。但是，这种循环读的方式在处理一个比较大的文件的时候，虽然我们能在while(1)完整的读取数据，但是会造成当前IO的处理时间过长，应用程序就没有时间去处理其他IO事件。因此，<strong>较小的文件我们用ET+循环读的方式，较大的文件我们用LT+一次性读的方式</strong>。并且，监听的fd适合用水平触发。</p><h1 id="select与epoll的比较"><a href="#select与epoll的比较" class="headerlink" title="select与epoll的比较"></a>select与epoll的比较</h1><table><thead><tr><th align="center"></th><th align="center">select</th><th align="center">epoll</th></tr></thead><tbody><tr><td align="center">操作方式</td><td align="center">遍历</td><td align="center">回调</td></tr><tr><td align="center">底层实现</td><td align="center">数组</td><td align="center">红黑树</td></tr><tr><td align="center">IO效率</td><td align="center">每次调用都进行线性遍历，时间复杂度为O(n)</td><td align="center">事件通知方式，每当一个fd有事件就绪，我们就把fd放到就绪链表里，epoll_wait()调用只要观察就绪链表有没有数据即可，时间复杂度为O(1)</td></tr><tr><td align="center">最大连接数</td><td align="center">1024（x86）或2048（x64）</td><td align="center">无上限</td></tr><tr><td align="center">fd拷贝</td><td align="center">每次调用select都要把fd集合从用户态拷贝到内核态</td><td align="center">调用epoll_ctl()时拷贝到内核并保存，之后每次调用epoll_wait()不拷贝</td></tr></tbody></table><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>epoll是Linux目前大规模网络并发程序的首选模型，在绝大多数情况下性能远超select和poll。目前主流的一些高性能web服务器框架都是基于epoll的reactor反应堆实现的，比如libevent,redis,nginx等。但是，在并发量不高的情况下（C10k以内），多线程+阻塞IO方式性能可能会更好。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;网络IO&quot;&gt;&lt;a href=&quot;#网络IO&quot; class=&quot;headerlink&quot; title=&quot;网络IO&quot;&gt;&lt;/a&gt;网络IO&lt;/h1&gt;&lt;p&gt;网络I/O会涉及两个系统对象，一个是用户调用IO的进程或线程（即应用程序），另一个是内核空间的内核系统。比如当发生IO操作read时，它会经历两个阶段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;等待数据准备就绪&lt;/li&gt;
&lt;li&gt;将数据从内核拷贝到进程或者线程中&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因为在以上两个阶段各有不同的情况，所以出现了多种网络IO模型。本文主要是介绍多路复用IO之epoll的实现以及与select的对比。&lt;/p&gt;
&lt;h1 id=&quot;IO多路复用&quot;&gt;&lt;a href=&quot;#IO多路复用&quot; class=&quot;headerlink&quot; title=&quot;IO多路复用&quot;&gt;&lt;/a&gt;IO多路复用&lt;/h1&gt;&lt;p&gt;IO多路复用(multiplexing)的本质是通过系统内核缓冲IO数据，让单个process可以监听多个文件描述符，当某个描述符就绪时（一般是读就绪或写就绪），就能通知应用程序进行相应的读操作或写操作。我们以读操作为例，看一下select API是如何工作的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2021/04/05/TCP%E6%9C%8D%E5%8A%A1%E5%99%A8epoll%E7%9A%84%E5%A4%9A%E7%A7%8D%E5%AE%9E%E7%8E%B0/image1.png&quot; alt=&quot;image-20210405111318568&quot;&gt;&lt;/p&gt;
&lt;p&gt;当用户调用了select API，那么整个进程就会阻塞，系统就会从用户态进入内核态，Kernel就会监听所有select负责的socket，当任何一个socket中的数据就绪时，select就会返回。用户进程再调用read API，将数据从Kernel拷贝到用户进程。&lt;/p&gt;
&lt;p&gt;从上图可以看出，实时上，我们进行了两个系统调用（select和read），而阻塞IO（blocking IO）事实上只进行了一次系统调用（read），但是使用select的好处是，在一个线程内，它可以监听所有socket的IO请求。当用户可以注册多个socket，可以通过不断地调用select读取被激活的socket，就能达到在一个线程里处理同时处理多个IO请求的目的。&lt;/p&gt;</summary>
    
    
    
    <category term="网络编程" scheme="https://liangxiaocode.github.io/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>TestCode</title>
    <link href="https://liangxiaocode.github.io/2021/03/31/TestCode/"/>
    <id>https://liangxiaocode.github.io/2021/03/31/TestCode/</id>
    <published>2021-03-30T16:00:00.000Z</published>
    <updated>2021-04-16T12:16:25.570Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h1><p>链接：<a href="https://pan.baidu.com/s/1c2x0LKuEh8dP_vdyhEhyhA">https://pan.baidu.com/s/1c2x0LKuEh8dP_vdyhEhyhA</a><br>提取码：sw66 </p><hr><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p>链接：<a href="https://pan.baidu.com/s/13-_vz8RSM5wsTg3w2ir0Jg">https://pan.baidu.com/s/13-_vz8RSM5wsTg3w2ir0Jg</a><br>提取码：mr54 </p><hr><h1 id="手撕简答的线程池"><a href="#手撕简答的线程池" class="headerlink" title="手撕简答的线程池"></a>手撕简答的线程池</h1><p>链接：<a href="https://pan.baidu.com/s/1OgCqWcCrEV5f6poD335KGw">https://pan.baidu.com/s/1OgCqWcCrEV5f6poD335KGw</a><br>提取码：f89d </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数据结构与算法&quot;&gt;&lt;a href=&quot;#数据结构与算法&quot; class=&quot;headerlink&quot; title=&quot;数据结构与算法&quot;&gt;&lt;/a&gt;数据结构与算法&lt;/h1&gt;&lt;p&gt;链接：&lt;a href=&quot;https://pan.baidu.com/s/1c2x0LKuEh8dP_</summary>
      
    
    
    
    <category term="测试代码" scheme="https://liangxiaocode.github.io/categories/%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81/"/>
    
    
    <category term="sourcecode" scheme="https://liangxiaocode.github.io/tags/sourcecode/"/>
    
  </entry>
  
  <entry>
    <title>几种常见设计模式</title>
    <link href="https://liangxiaocode.github.io/2021/03/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://liangxiaocode.github.io/2021/03/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-03-29T16:00:00.000Z</published>
    <updated>2021-04-04T02:36:55.128Z</updated>
    
    <content type="html"><![CDATA[<p>在聊设计模式之前，我们先来看一下模式设计都有哪些原则，即常用的二十三种设计模式都应该遵守的原则：</p><ul><li>依赖倒置原则<ul><li>高层模块不应该依赖低层模块，二者都应该依赖抽象；</li><li>抽象不应该依赖具体实现，具体实现一个依赖于抽象；</li></ul></li><li>开放封闭原则<ul><li>一个类应该对扩展开发，对修改关闭；</li></ul></li><li>面向接口编程<ul><li>不将变量类型声明为某个特定的具体类，而是声明为某个接口；</li><li>客户程序无需获知对象的具体类型，只需要直到对象所具有的接口；</li><li>减少系统中各部分的依赖关系，从而实现“高内聚、松耦合”的类型设计方案；</li></ul></li><li><strong>封装变化点</strong><ul><li>将稳定点和变化点分离，扩展修改变化点，让稳定点和变化点实现层次分离；</li></ul></li><li>单一职责原则<ul><li>一个类应该仅有一个引起它变化的原因；</li></ul></li><li>里氏替换原则<ul><li>子类必须能够替换掉它的父类型；主要出现在子类覆盖父类实现，原来使用父类的程序可能出现错误；覆盖父类的方法却没实现父类方法的职责；</li></ul></li><li>接口隔离原则<ul><li>不应该强迫客户依赖于他们不用的方法；</li><li>一般用于处理一个类拥有比较多的接口，而这些接口设计很多职责；</li></ul></li><li>对象组合优于类继承<ul><li>继承耦合度高，组合耦合度低；</li></ul></li></ul><span id="more"></span><h2 id="什么情况下使用设计模式"><a href="#什么情况下使用设计模式" class="headerlink" title="什么情况下使用设计模式"></a>什么情况下使用设计模式</h2><ul><li>系统的关键依赖点；</li><li>能明确找到变化点；</li><li>能明确找到复用方向；</li><li>对需求变化方向熟悉；</li></ul><h2 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h2><ul><li>静态变为动态；</li><li>早绑定变为晚绑定；</li><li>继承变为组合；</li><li>编译时依赖变为运行时依赖；</li><li>紧耦合变为松耦合；</li></ul><h2 id="为什么要学习设计模式"><a href="#为什么要学习设计模式" class="headerlink" title="为什么要学习设计模式"></a>为什么要学习设计模式</h2><ul><li>从已有的且证明有效的设计模式中获取灵感，少走弯路；</li><li>通用语言，直到在已有的设计模式扩展代码；</li><li>体会模式设计，设计自己的行之有效的设计模式；</li></ul><h2 id="学习设计模式的步骤"><a href="#学习设计模式的步骤" class="headerlink" title="学习设计模式的步骤"></a>学习设计模式的步骤</h2><ul><li>深刻理解设计原则；</li><li>知道设计模式的变化点与稳定点；</li><li>能在已使用的设计模式中，知道如何扩展；</li><li>在复杂的需求中，抽象出已有的设计模式；</li></ul><h2 id="模板方法"><a href="#模板方法" class="headerlink" title="模板方法"></a>模板方法</h2><p><img src="/2021/03/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image1.png" alt="image-20210329214941091"></p><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p><img src="/2021/03/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image2.png" alt="image-20210329215132811"></p><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>代码</p><ul><li><p>版本1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内存栈区</span></span><br><span class="line"><span class="comment">// 内存堆区</span></span><br><span class="line"><span class="comment">// 常数区</span></span><br><span class="line"><span class="comment">// 静态区 系统释放</span></span><br><span class="line"><span class="comment">// ⼆进制代码区</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="keyword">static</span> Singleton * <span class="title">GetInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (_instance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line"> _instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> _instance;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> Singleton()&#123;&#125;<span class="comment">//构造</span></span><br><span class="line"> Singleton(<span class="keyword">const</span> Singleton &amp;clone)&#123;&#125; <span class="comment">//拷⻉构造</span></span><br><span class="line"> Singleton&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton&amp;) &#123;&#125;</span><br><span class="line"> <span class="keyword">static</span> Singleton * _instance; </span><br><span class="line">&#125;</span><br><span class="line">Singleton* Singleton::_instance = <span class="literal">nullptr</span>;<span class="comment">//静态成员需要初始化</span></span><br></pre></td></tr></table></figure><p>版本1存在的问题：</p><ul><li>没有加锁，存在多线程问题</li><li>new Singleton()后没有释放内存，存在内存泄漏的问题</li></ul></li><li><p>版本2</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="keyword">static</span> Singleton * <span class="title">GetInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (_instance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line"> _instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"> atexit(Destructor);<span class="comment">//解决了内存泄漏的问题</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> _instance;</span><br><span class="line"> &#125;</span><br><span class="line"> ~Singleton() &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Destructor</span><span class="params">()</span> </span>&#123; <span class="comment">//静态成员函数只能访问类成员函数，不能访问非类成员函数</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="literal">nullptr</span> != _instance) &#123;</span><br><span class="line"> <span class="keyword">delete</span> _instance;</span><br><span class="line"> _instance = <span class="literal">nullptr</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> Singleton();<span class="comment">//构造</span></span><br><span class="line"> Singleton(<span class="keyword">const</span> Singleton &amp;cpy); <span class="comment">//拷⻉构造</span></span><br><span class="line"> Singleton&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton&amp;) &#123;&#125;</span><br><span class="line"> <span class="keyword">static</span> Singleton * _instance; </span><br><span class="line">&#125;</span><br><span class="line">Singleton* Singleton::_instance = <span class="literal">nullptr</span>;<span class="comment">//静态成员需要初始化</span></span><br><span class="line"><span class="comment">// 还可以使⽤ 内部类，智能指针来解决； 此时还有线程安全问题</span></span><br></pre></td></tr></table></figure></li><li><p>版本3</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span> <span class="comment">// 懒汉模式 lazy load</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="keyword">static</span> Singleton * <span class="title">GetInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="comment">//std::lock_guard&lt;std::mutex&gt; lock(_mutex); // 3.1 切换线程</span></span><br><span class="line"> <span class="keyword">if</span> (_instance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line"> <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(_mutex)</span></span>; <span class="comment">// 3.2</span></span><br><span class="line"> <span class="keyword">if</span> (_instance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line"> _instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"> atexit(Destructor);</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> <span class="keyword">return</span> _instance;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Destructor</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (<span class="literal">nullptr</span> != _instance) &#123;</span><br><span class="line"> <span class="keyword">delete</span> _instance;</span><br><span class="line"> _instance = <span class="literal">nullptr</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> Singleton()&#123;&#125; <span class="comment">//构造</span></span><br><span class="line"> Singleton(<span class="keyword">const</span> Singleton &amp;cpy)&#123;&#125; <span class="comment">//拷⻉构造</span></span><br><span class="line"> Singleton&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton&amp;) &#123;&#125;</span><br><span class="line"> <span class="keyword">static</span> Singleton * _instance;</span><br><span class="line"> <span class="keyword">static</span> <span class="built_in">std</span>::mutex _mutex; </span><br><span class="line">&#125;</span><br><span class="line">Singleton* Singleton::_instance = <span class="literal">nullptr</span>;<span class="comment">//静态成员需要初始化</span></span><br><span class="line"><span class="built_in">std</span>::mutex Singleton::_mutex; <span class="comment">//互斥锁初始化</span></span><br></pre></td></tr></table></figure></li><li><p>版本3</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="keyword">static</span> Singleton * <span class="title">GetInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> Singleton* tmp = _instance.load(<span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line"> <span class="built_in">std</span>::atomic_thread_fence(<span class="built_in">std</span>::memory_order_acquire);<span class="comment">//获取内存屏障</span></span><br><span class="line"> <span class="keyword">if</span> (tmp == <span class="literal">nullptr</span>) &#123;</span><br><span class="line"> <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(_mutex)</span></span>;</span><br><span class="line"> tmp = _instance.load(<span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line"> <span class="keyword">if</span> (tmp == <span class="literal">nullptr</span>) &#123;</span><br><span class="line"> tmp = <span class="keyword">new</span> Singleton;</span><br><span class="line"> <span class="built_in">std</span>::atomic_thread_fence(<span class="built_in">std</span>::memory_order_release);<span class="comment">//释放内存屏</span></span><br><span class="line">障</span><br><span class="line"> _instance.store(tmp, <span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line"> atexit(Destructor);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> tmp;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Destructor</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> Singleton* tmp = _instance.load(<span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line"> <span class="keyword">if</span> (<span class="literal">nullptr</span> != tmp) &#123;</span><br><span class="line"> <span class="keyword">delete</span> tmp;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> Singleton()&#123;&#125;</span><br><span class="line"> Singleton(<span class="keyword">const</span> Singleton&amp;) &#123;&#125;</span><br><span class="line"> Singleton&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton&amp;) &#123;&#125;</span><br><span class="line"> <span class="keyword">static</span> <span class="built_in">std</span>::atomic&lt;Singleton*&gt; _instance;</span><br><span class="line"> <span class="keyword">static</span> <span class="built_in">std</span>::mutex _mutex;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">std</span>::atomic&lt;Singleton*&gt; Singleton::_instance;<span class="comment">//静态成员需要初始化</span></span><br><span class="line"><span class="built_in">std</span>::mutex Singleton::_mutex; <span class="comment">//互斥锁初始化</span></span><br><span class="line"><span class="comment">// g++ Singleton.cpp -o singleton -std=c++11</span></span><br></pre></td></tr></table></figure></li><li><p>版本5</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c++11 magic static 特性：如果当变量在初始化的时候，并发同时进⼊声明语句，并发</span></span><br><span class="line">线程将会阻塞等待初始化结束。</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> ~Singleton()&#123;&#125;</span><br><span class="line"> <span class="function"><span class="keyword">static</span> Singleton&amp; <span class="title">GetInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"> <span class="keyword">return</span> instance;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> Singleton()&#123;&#125;</span><br><span class="line"> Singleton(<span class="keyword">const</span> Singleton&amp;) &#123;&#125;</span><br><span class="line"> Singleton&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton&amp;) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 继承 Singleton</span></span><br><span class="line"><span class="comment">// g++ Singleton.cpp -o singleton -std=c++11</span></span><br><span class="line"><span class="comment">/*该版本具备 版本5 所有优点：</span></span><br><span class="line"><span class="comment">1. 利⽤静态局部变量特性，延迟加载；</span></span><br><span class="line"><span class="comment">2. 利⽤静态局部变量特性，系统⾃动回收内存，⾃动调⽤析构函数；</span></span><br><span class="line"><span class="comment">3. 静态局部变量初始化时，没有 new 操作带来的cpu指令reorder操作；</span></span><br><span class="line"><span class="comment">4. c++11 静态局部变量初始化时，具备线程安全；</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>版本6</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="keyword">static</span> T&amp; <span class="title">GetInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">static</span> T instance; <span class="comment">// 这⾥要初始化DesignPattern，需要调⽤</span></span><br><span class="line">DesignPattern 构造函数，同时会调⽤⽗类的构造函数。</span><br><span class="line"> <span class="keyword">return</span> instance;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"> <span class="keyword">virtual</span> ~Singleton() &#123;&#125;</span><br><span class="line"> Singleton() &#123;&#125; <span class="comment">// protected修饰构造函数，才能让别⼈继承</span></span><br><span class="line"> Singleton(<span class="keyword">const</span> Singleton&amp;) &#123;&#125;</span><br><span class="line"> Singleton&amp; <span class="keyword">operator</span> =(<span class="keyword">const</span> Singleton&amp;) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DesignPattern</span> :</span> <span class="keyword">public</span> Singleton&lt;DesignPattern&gt; &#123;</span><br><span class="line"> <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>&lt;</span>DesignPattern&gt;; <span class="comment">// friend 能让 Singleton&lt;T&gt; 访</span></span><br><span class="line">问到 DesignPattern构造函数</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> DesignPattern()&#123;&#125;</span><br><span class="line"> DesignPattern(<span class="keyword">const</span> DesignPattern&amp;) &#123;&#125;</span><br><span class="line"> DesignPattern&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> DesignPattern&amp;) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p><img src="/2021/03/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image3.png" alt="image-20210330144607053"></p><h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><ul><li><p>要点</p><ul><li>解耦请求⽅和处理⽅，请求⽅不知道请求是如何被处理，处理⽅的组成是由相互独⽴的⼦处理构成，⼦处理流程通过链表的⽅式连接，⼦处理请求可以按任意顺序组合；</li><li>责任链请求强调请求最终由⼀个⼦处理流程处理；通过了各个⼦处理条件判断；</li><li>责任链扩展就是功能链，功能链强调的是，⼀个请求依次经由功能链中的⼦处理流程处理；</li><li>充分体现了单⼀职责原则；将职责以及职责顺序运⾏进⾏抽象，那么职责变化可以任意扩展，同时职责顺序也可以任意扩展；</li></ul><p><img src="/2021/03/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image4.png" alt="image-20210330154627422"></p></li></ul><h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><ul><li>要点<ul><li>通过采⽤组合⽽⾮继承的⼿法， 装饰器模式实现了在运⾏时动态扩展对象功能的能⼒，⽽且可以根据需要扩展多个功能。 避免了使⽤继承带来的“灵活性差”和“多⼦类衍⽣问题”。</li><li>不是解决“多⼦类衍⽣的多继承”问题，⽽是解决“⽗类在多个⽅向上的扩展功能”问题；</li><li>装饰器模式把⼀系列复杂的功能分散到每个装饰器当中，⼀般⼀个装饰器只实现⼀个功能，实现复⽤装饰器的功能；</li></ul><img src="/2021/03/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image5.png" alt="image-20210331095816077"></li></ul><h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><ul><li><p>要点</p><ul><li>解决创建过程比较复杂，希望对外隐藏这些细节；<ul><li>比如线程池，连接池；</li><li>隐藏对象真实类型；</li><li>对象创建会有很多参数来决定如何创建；</li><li>创建对象有复杂的依赖关系；</li></ul></li></ul><p><img src="/2021/03/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image6.png" alt="image-20210331103526401"></p></li></ul><h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p>![image-20210331105006412]image7.png)</p><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><ul><li>要点<ul><li>原来的接⼝是稳定的，新的外来的需求是变化的，那么可以通过继承原来的接⼝，让原来的接⼝继续保持稳定，在⼦类通过组合的⽅式来扩展功能；</li></ul></li></ul><p><img src="/2021/03/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image8.png" alt="image-20210331110516282"></p><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><ul><li><p>要点</p><ul><li>远程代理（隐藏一个对象存在不同的地址空间的事实），虚代理（延迟加载lazyload），保护代理（在代理前后做额外操作，权限管理，引用计数等）；</li><li>在分布式系统中，actor模型(skynet)等常用的设计模式；</li></ul><p><img src="/2021/03/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image9.png" alt="image-20210401095806508"></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在聊设计模式之前，我们先来看一下模式设计都有哪些原则，即常用的二十三种设计模式都应该遵守的原则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;依赖倒置原则&lt;ul&gt;
&lt;li&gt;高层模块不应该依赖低层模块，二者都应该依赖抽象；&lt;/li&gt;
&lt;li&gt;抽象不应该依赖具体实现，具体实现一个依赖于抽象；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;开放封闭原则&lt;ul&gt;
&lt;li&gt;一个类应该对扩展开发，对修改关闭；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;面向接口编程&lt;ul&gt;
&lt;li&gt;不将变量类型声明为某个特定的具体类，而是声明为某个接口；&lt;/li&gt;
&lt;li&gt;客户程序无需获知对象的具体类型，只需要直到对象所具有的接口；&lt;/li&gt;
&lt;li&gt;减少系统中各部分的依赖关系，从而实现“高内聚、松耦合”的类型设计方案；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;封装变化点&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;将稳定点和变化点分离，扩展修改变化点，让稳定点和变化点实现层次分离；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;单一职责原则&lt;ul&gt;
&lt;li&gt;一个类应该仅有一个引起它变化的原因；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;里氏替换原则&lt;ul&gt;
&lt;li&gt;子类必须能够替换掉它的父类型；主要出现在子类覆盖父类实现，原来使用父类的程序可能出现错误；覆盖父类的方法却没实现父类方法的职责；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;接口隔离原则&lt;ul&gt;
&lt;li&gt;不应该强迫客户依赖于他们不用的方法；&lt;/li&gt;
&lt;li&gt;一般用于处理一个类拥有比较多的接口，而这些接口设计很多职责；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;对象组合优于类继承&lt;ul&gt;
&lt;li&gt;继承耦合度高，组合耦合度低；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://liangxiaocode.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="面试常问题" scheme="https://liangxiaocode.github.io/tags/%E9%9D%A2%E8%AF%95%E5%B8%B8%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统运行时性能参数命令</title>
    <link href="https://liangxiaocode.github.io/2021/03/29/Linux%E7%B3%BB%E7%BB%9F%E8%BF%90%E8%A1%8C%E6%97%B6%E6%80%A7%E8%83%BD%E5%8F%82%E6%95%B0%E5%91%BD%E4%BB%A4/"/>
    <id>https://liangxiaocode.github.io/2021/03/29/Linux%E7%B3%BB%E7%BB%9F%E8%BF%90%E8%A1%8C%E6%97%B6%E6%80%A7%E8%83%BD%E5%8F%82%E6%95%B0%E5%91%BD%E4%BB%A4/</id>
    <published>2021-03-28T16:00:00.000Z</published>
    <updated>2021-04-04T02:21:39.305Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Linux、cpu、硬盘、内存、网络状态监控</li><li>Linux、cpu、硬盘、内存、网络性能测试</li><li>Linux、cpu、硬盘、内存、网络性常见性能问题的排查</li><li>Linux常用命令的用法</li></ul><span id="more"></span><h2 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h2><p>常用的命令：</p><ul><li>free用于显示系统内存的使用情况，包括总统内存、已经使用的内存；还可以用于显示系统内核使用的缓冲区，包括缓冲(buffer)和缓存(cache)等</li><li>ping命令是用于检测网络故障的常用命令，可以用来测试一台主机到另一台主机的网络是否连通</li><li>vmstat(VirtualMemoryStatistics,虚拟内存统计)</li><li>iostat 用于报告CPU统计信息和整个系统、适配器、tty设备、磁盘和CD-ROM的输入/输出统计信息</li><li>dstat 显示了CPU使用情况，磁盘io情况，网络发包情况和换页情况，输出是彩色的，可读性强，相对于vmstat和iostat的输入更加详细且较为直观。</li><li>pidstat 主要用于监控全部或指定进程占用系统资源的情况，如CPU，内存、设备IO、任务切换、线程等。</li><li>top 汇总区域显示了五个方面的系统性能信息：负载、进程状态、CPU使用率、内存使用、SWAP分区。</li><li>iotop LINUX进程实时监控工具，界面风格类似top命令。</li><li>htop Linux系统中的一个互动的进程查看器，一个文本模式的应用程序(在控制台或者Xshell终端中)，需要nucurses。</li><li>mpstat 报告CPU的统计信息。</li><li>netstat 用于显示与IP、TCP、UDP和ICMP协议相关的统计数据，一般用于检验本机各端口的网络连接情况。</li><li>ps 显示当前进程的状态</li><li>strace 跟踪程序执行过程中产生的系统调用以及接收到的信号，帮助分析程序或命令执行中遇到的异常情况。</li><li>Itrace 跟踪进程调用库函数的情况。</li><li>uptime 能够打印系统总共运行了多长时间和系统的平均负载，uptime命令最后三个数字的含义分别是1分钟，5分钟，15分钟内的系统平均负载。</li><li>lsof 是一个列出当前系统打开文件的工具。</li><li><strong>perf</strong> 是Linux kernel自带的系统性能优化工具。优势在于与Linux kernel的紧密结合，它可以最先应用到加入Kernel的new feature，用于查看热点函数，查看cashe miss的比率，从而帮助开发者来优化程序性能。</li><li>tcpdump</li><li>sar</li><li>blktrace</li><li><img src="/2021/03/29/Linux%E7%B3%BB%E7%BB%9F%E8%BF%90%E8%A1%8C%E6%97%B6%E6%80%A7%E8%83%BD%E5%8F%82%E6%95%B0%E5%91%BD%E4%BB%A4/image1.png" alt="image-20210329155632068"></li></ul><p>Linux CPU的使用率主要是从以下几个维度进行统计：</p><ul><li>%usr: 普通进程在用户模式下执行的时间。</li><li>%sys: 进程在内核模式下的执行时间。</li><li>%nice: 被提高优先级的进程在用户模式下的执行时间。</li><li>%idle: 空闲时间。</li><li>%iowait: 等待I/O完成的时间。</li><li>%irp: 处理硬中断请求花费的时间。</li><li>%soft: 处理软中断请求花费的时间。</li><li>%steal: 是衡量虚拟机CPU的指标，是指分配给本虚拟机的时间片被同一宿主机别的虚拟机占用，一般%steal值较高时，说明宿主机的资源使用已达到瓶颈。</li></ul><p><strong>⼀般情况下，CPU⼤部分的时间⽚都是消耗在⽤户态和内核态上。</strong></p><p>​       sys和user间的⽐例是相互影响的，%sys⽐例⾼意味着被测服务频繁的进⾏⽤户态和系统态之间的切换， 会带来⼀定的CPU开销，这样分配处理业务的时间⽚就会较少，造成系统性能的下降。对于IO密集型系 统，⽆论是⽹络IO还是磁盘IO，⼀般都会产⽣⼤量的中断，从⽽导致%sys相对升⾼，其中磁盘IO密集型系 统，对磁盘的读写需要占⽤⼤量的CPU，会导致%iowait的值⼀定⽐例的升⾼，所以当出现%iowait较⾼ 时，需排查是否存在⼤量的不合理的⽇志操作，或者频繁的数据载⼊等情况；</p><h3 id="uptime"><a href="#uptime" class="headerlink" title="uptime"></a>uptime</h3><p>系统的平均负载是指在特定的时间间隔内队列运行的平均进程数。如果一个进程满足以下条件，它就会位于运行队列中：</p><ul><li>它没有在等待I/O操作的结果</li><li>它没有主动进入等待状态（业绩也是没有调用wait()相关的系统API）</li><li>没有被停止</li></ul><p>如果每个CPU内核的当前活动进程数不大于3的话，那么系统的性能还算可以支持；如果每个CPU内核的任务数大于5，那么这台机器性能有严重问题；例如你是一个双核的CPU的话，当Load Average为6的时候就说明机器以及被充分利用。</p><p><img src="/2021/03/29/Linux%E7%B3%BB%E7%BB%9F%E8%BF%90%E8%A1%8C%E6%97%B6%E6%80%A7%E8%83%BD%E5%8F%82%E6%95%B0%E5%91%BD%E4%BB%A4/image2.png" alt="image-20210329161426430"></p><h3 id="ulimit"><a href="#ulimit" class="headerlink" title="ulimit"></a>ulimit</h3><p>为了提高性能，可以根据硬件资源的具体情况设置各个用户的最大进程数和打开的最大文件句柄数。可以用ulimit -a来显示当前的各种系统对用户使用资源的限制：</p><p><img src="/2021/03/29/Linux%E7%B3%BB%E7%BB%9F%E8%BF%90%E8%A1%8C%E6%97%B6%E6%80%A7%E8%83%BD%E5%8F%82%E6%95%B0%E5%91%BD%E4%BB%A4/image3.png" alt="image-20210329162011475"></p><p>设置用户最大进程数：ulimit -u 1024</p><p>设置用户可以打开的最大文件句柄数：ulimit -n 65535</p><h3 id="curl-http"><a href="#curl-http" class="headerlink" title="curl http"></a>curl http</h3><p>由于当前的线上服务较多地使用了RESTful风格的API，所以集成测试就需要进行HTTP的调用，查看返回的结果是否符合预期。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl -i <span class="string">&quot;http://www.taobao.com&quot;</span> <span class="comment">#打印请求响应头信息</span></span><br><span class="line">curl -l <span class="string">&quot;http://www.taobao.com&quot;</span> <span class="comment">#仅打印http头</span></span><br><span class="line">curl -v <span class="string">&quot;http://www.taobao.com&quot;</span> <span class="comment">#打印更多调试信息</span></span><br><span class="line">curl -verbose <span class="string">&quot;http://www.taobao.com&quot;</span> <span class="comment">#打印更多调试信息</span></span><br></pre></td></tr></table></figure><h3 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h3><p>sed命令是用来批处理修改文本内容的，比如批量替换配置中的某个IP。sed命令在处理时，会先读取一行，把当前处理的行存储在临时缓冲区中，处理完缓冲区中的内容后，打印到屏幕上。然后再读入下一行，执行下一个循环。不断重复，直到文件末尾。</p><p><a href="https://github.com/Black-Gold/Learn/blob/1ee76ca2a9bbbbfe04850a1ccc9b9658e1eb39de/Linux_man_cn/sed.md">https://github.com/Black-Gold/Learn/blob/1ee76ca2a9bbbbfe04850a1ccc9b9658e1eb39de/Linux_man_cn/sed.md</a> </p><h3 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h3><p>awk和sed命令类似，只不过sed擅长取行，awk擅长取列。原理：一般是遍历一个文件中的每一行，然后分别对文件的每一行进行处理。</p><p><img src="/2021/03/29/Linux%E7%B3%BB%E7%BB%9F%E8%BF%90%E8%A1%8C%E6%97%B6%E6%80%A7%E8%83%BD%E5%8F%82%E6%95%B0%E5%91%BD%E4%BB%A4/image4.png" alt="image-20210329164615148"></p><p>awk和我们通常的程序不太一样。它分为四个部分：</p><ul><li>BEGIN开头部分，可选。用来设置一些参数，输出一些表头，定义一些变量等。上面的命令仅打印了一行信息。</li><li>END结尾部分，可选。用来计算一些汇总逻辑，或者输出这些内容。上面的命令，使用简单的for循环打印数组rt[i]中的内容。</li><li>Pattern 匹配部分，可选。用来匹配一些需要处理的行。上面的命令中，只匹配tcp开头的行，其他的不处理。</li><li>Action 模块。主要逻辑，按行执行。</li></ul><p><strong>注意点</strong></p><ol><li>awk的主程序部分用单引号’包围，而不是双引号。</li><li>awk的列开始的index是0，而不是1。</li></ol><p><a href="https://github.com/Black-Gold/Learn/blob/1ee76ca2a9bbbbfe04850a1ccc9b9658e1eb39de/Linux_man_cn/a#wk.md">https://github.com/Black-Gold/Learn/blob/1ee76ca2a9bbbbfe04850a1ccc9b9658e1eb39de/Linux_man_cn/a#wk.md</a> </p><h2 id="查看活动进程的命令"><a href="#查看活动进程的命令" class="headerlink" title="查看活动进程的命令"></a>查看活动进程的命令</h2><ul><li><p>ps用于显示系统内的所用进程。-l或l 采用详细的格式来显示进程状态。</p></li><li><p>top用于查看活动进程的CPU和内存信息，能够实时显示系统中各个进程的资源占用情况，可以按照CPU、内存的使用情况和执行时间对进程进行排序。使用方式：top。</p></li><li><p>pidstat用于监控全部或指定的进程占用系统资源的情况，包括CPU、内存、磁盘I/O、线程切换、线程数等数据。</p><p>​    使用范例：pidstat -urd -p 1 #-u查看CPU的使用信息，-r查看内存的使用信息，-d查看硬盘的使用信息。</p><p><img src="/2021/03/29/Linux%E7%B3%BB%E7%BB%9F%E8%BF%90%E8%A1%8C%E6%97%B6%E6%80%A7%E8%83%BD%E5%8F%82%E6%95%B0%E5%91%BD%E4%BB%A4/image5.png" alt="image-20210329171955370"></p></li></ul><h2 id="查看分区使用情况"><a href="#查看分区使用情况" class="headerlink" title="查看分区使用情况"></a>查看分区使用情况</h2><p>swapon用来查看交互分区的使用情况，使用方法：swapon -s。swap分区通常被称为交换分区，这是一块特殊的硬盘空间，当实际内存不够用时，操作系统会从内存中取出一部分暂时用不到的数据，放在交换分区中，从而为当前运行的程序腾出足够的内存空间。一般来讲，swap分区容量应大于物理内存大小，建议时内存的两倍，但不超过2GB。</p><h2 id="查看网络信息和网络监控命令"><a href="#查看网络信息和网络监控命令" class="headerlink" title="查看网络信息和网络监控命令"></a>查看网络信息和网络监控命令</h2><ul><li><p>ifconfig用于查看机器挂载的网卡情况</p></li><li><p>ping：ping -c 3 baidu.com</p><p><img src="/2021/03/29/Linux%E7%B3%BB%E7%BB%9F%E8%BF%90%E8%A1%8C%E6%97%B6%E6%80%A7%E8%83%BD%E5%8F%82%E6%95%B0%E5%91%BD%E4%BB%A4/image6.png" alt="image-20210330163902516"></p><ul><li>baidu.com(220.181.38.148):主机的域名和IP</li><li>56(84):不带包头包大小和带包头的包大小</li><li>icmp_seq:ping序列，从1开始，如果数字不是顺序增加的意味着丢包了</li><li>ttl:每经过一个路由点，就把预设的TTL数值减1，直到TTL=1就把报文丢掉。从baidu.com返回的报文，到本地主机这里，还剩下的TTL有多少。</li><li>time:响应时间，越小越好。</li><li>倒数第二行：发出去的包数，返回的包数，丢包率，总耗费时间。</li><li>最小/平均/最大响应时间。</li><li>mdev:表示ICMP包的RTT偏离平均值的程度，主要用来衡量网速的稳定性。mdev的值越大说明网速越不稳定。</li></ul></li><li><p>telnet:TCP/IP协议簇的一员，网络远程登录服务的标准协议。telnet IP PORT。端口是23。</p></li><li><p>nc:<strong>验证服务器端口有没有开放。</strong></p></li><li><p>mtr:是Linux系统中的网络连通性测试工具，也可以用来检测丢包率。</p></li><li><p>nslookup:域名解析工具命令。</p></li><li><p>traceroute:可以提供从用户主机到互联网另一端的主机路径，虽然每次数据包由同一出发点到达同一目的地的路径可能不一样，但通常大多数情况下路径是相同的。</p><p><img src="/2021/03/29/Linux%E7%B3%BB%E7%BB%9F%E8%BF%90%E8%A1%8C%E6%97%B6%E6%80%A7%E8%83%BD%E5%8F%82%E6%95%B0%E5%91%BD%E4%BB%A4/image7.png" alt="image-20210330172106091"></p><p>每个记录表示网络一跳，每跳一次表示经过一个网关或者路由；我们看到每行有三个时间，单位是毫秒，指的是这一跳需要的时间。</p></li><li><p>tcpdump:网络状况分析和跟踪工具，是可以用来抓包的实用命令，需要对TCP/IP有所熟悉，过滤使用的信息都是TCP/IP格式。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;Linux、cpu、硬盘、内存、网络状态监控&lt;/li&gt;
&lt;li&gt;Linux、cpu、硬盘、内存、网络性能测试&lt;/li&gt;
&lt;li&gt;Linux、cpu、硬盘、内存、网络性常见性能问题的排查&lt;/li&gt;
&lt;li&gt;Linux常用命令的用法&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://liangxiaocode.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>海量数据去重hash与布隆过滤器</title>
    <link href="https://liangxiaocode.github.io/2021/03/25/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%8E%BB%E9%87%8Dhash%E4%B8%8E%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    <id>https://liangxiaocode.github.io/2021/03/25/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%8E%BB%E9%87%8Dhash%E4%B8%8E%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</id>
    <published>2021-03-24T16:00:00.000Z</published>
    <updated>2021-04-03T04:18:48.015Z</updated>
    
    <content type="html"><![CDATA[<h3 id="面试经常问到的问题一：缓存穿透问题如何解决"><a href="#面试经常问到的问题一：缓存穿透问题如何解决" class="headerlink" title="面试经常问到的问题一：缓存穿透问题如何解决"></a>面试经常问到的问题一：缓存穿透问题如何解决</h3><h4 id="什么是缓存穿透"><a href="#什么是缓存穿透" class="headerlink" title="什么是缓存穿透"></a>什么是缓存穿透</h4><ul><li>请求数据的时候，为了减轻落盘数据库(mysql)的访问压力，在server端与mysql之间加入一层缓冲数据层</li><li>穿透场景发生在，redis,mysql中都没数据时，server端向数据库请求数据时，请求压力全部涌向落盘数据库(mysql)</li></ul><h4 id="什么是数据请求步骤以及解决方法"><a href="#什么是数据请求步骤以及解决方法" class="headerlink" title="什么是数据请求步骤以及解决方法"></a>什么是数据请求步骤以及解决方法</h4><p><img src="/2021/03/25/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%8E%BB%E9%87%8Dhash%E4%B8%8E%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/image1.png" alt="image-20210403120209067"></p><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>从海量数据中查询某字符串是否存在</p><span id="more"></span><h3 id="set和map"><a href="#set和map" class="headerlink" title="set和map"></a>set和map</h3><ul><li>c++标准库（STL）中的set和map结构都是采⽤红⿊树实现的，它增删改查的时间复杂度是O(logn);</li><li>对于严格平衡⼆叉搜索树(AVL)，100w条数据组成的红⿊树，只需要⽐较20次就能找到该值；对于10亿条数据只需要⽐较30次就能找到该数据；也就是查找次数跟树的⾼度是⼀致的；</li><li>对于红⿊树来说平衡的是⿊节点⾼度，所以研究⽐较次数需要考虑树的⾼度差，最好情况某条树链路全是⿊节点，假设此时⾼度为h1，最差情况某条树链路全是⿊红节点间隔，那么此时树⾼度为2*h1;</li><li>另外set和map的关键区别是set不存储val字段；</li><li>优点：存储效率高，访问速度高效；</li><li>缺点：对于数据量大且查询字符串比较长且查询字符串相似时将会很麻烦；</li></ul><h3 id="unordered-map"><a href="#unordered-map" class="headerlink" title="unordered_map"></a>unordered_map</h3><ul><li><p>c++标准库（STL）中的unordered_map&lt;string, bool&gt;是采⽤hashtable实现的；</p></li><li><p>构成：数组+hash函数；</p></li><li><p>它是将字符串通过hash函数⽣成⼀个整数再映射到数组当中；它增删改查的时间复杂度是o(1);</p></li><li><p>hash函数的作⽤：<strong>避免插⼊的时候字符串的⽐较</strong>；hash函数计算出来的值通过对数组⻓度的取模能<strong>随机分布</strong>在数组当中；</p></li><li><p>hash函数⼀般返回的是64位整数，将多个⼤数映射到⼀个⼩数组中，必然会产⽣冲突；</p></li><li><p>如何选取hash函数？</p><ol><li><p>选取计算速度快；</p></li><li><p>哈希相似字符串能保持<strong>强随机分布性</strong>（防碰撞）；</p></li></ol></li><li><p>murmurhash1，<strong>murmurhash2</strong>，murmurhash3，<strong>siphash</strong>（redis6.0当中使⽤，rust等⼤多数语⾔选⽤的hash算法来实现hashmap），cityhash都具备强随机分布性。</p></li><li><p>负载因子：数据存储元素的个数、数组长度；负载因子越小，冲突越小；负载因子越大，冲突越大；</p></li></ul><h4 id="hash冲突解决方案"><a href="#hash冲突解决方案" class="headerlink" title="hash冲突解决方案"></a>hash冲突解决方案</h4><ul><li>链表法：如果链表过长，经验上通常超过256个节点的时候将链表结构转换为红黑树结构，时间复杂度由O(n)-&gt;O(log<del>2</del>n);</li><li>开放寻址法<ol><li>i+1,i+2,i+3,i+4 … i+n</li><li>i-1^2^ ,i+2^2^,i-3^2^,i+4^2^…</li></ol></li></ul><p>这两种都会导致<strong>同类hash聚集</strong>；也就是近似值它的hash值也近似，那么它的数组槽位也靠近，形成hash聚集；第⼀种同类聚集冲突在前，第⼆种只是将聚集冲突延后；</p><ul><li>同样的hashtable中节点存储了key和val，hashtable并没有要求key的⼤⼩顺序，我们同样可以修改代码让插⼊存在的数据变成修改操作；</li><li>优点：访问速度更快；<strong>不需要进⾏字符串⽐较</strong>；</li><li>缺点：需要引⼊策略避免冲突，存储效率不⾼；空间换时间；</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>红黑树和hashtable都不能解决海量数据问题，它们都需要存储具体字符串，如果数据量大，提供不了几百G的内存，因此需要尝试探寻不存储key的方案，并且拥有hashtable的优点（不需要比较字符串）</p><h3 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h3><ul><li><p>定义：布隆过滤器是一种概率型数据结构，它的特点时高效的插入和查询，能明确告知某个字符串一定不存在或者可能存在；</p></li><li><p>布隆过滤器相比传统的查询结构（比如：hashtabl,map,set等数据结构）更加高效，占用空间更小；但是其缺点就是它返回的结果是具有概率性的，结果存在误差，虽然这个误差是可控的；于此同时，它不支持删除操作；因为你不知道当前位=1的点是由哪个数据通过哪个hash函数映射过来的；</p></li><li><p>组成：由位图(bit数组)+n个hash函数；</p><p><img src="/2021/03/25/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%8E%BB%E9%87%8Dhash%E4%B8%8E%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/image2.png" alt="image-20210403120904421"></p></li><li><p>原理：当一个元素加入到位图的时候，我们通过K个hash函数将这个元素映射到位图的K个点，并把它们的当前位置为1；因此在检索时，再通过K个hash函数运算检测位图的K个点是否都为1；如果有不为1的点，那么可以认为该数据不存在；如果全部为1，则可能存在（存在误差）；</p></li><li><p>在实际应⽤过程中，布隆过滤器该如何使⽤？要选择多少个hash函数，要分配多少空间的位图，存储多少元素？另外如何控制假阳率（布隆过滤器能明确⼀定不存在，不能明确⼀定存在，那么存在的判断是有误差的，假阳率就是错误判断存在的概率）？</p></li></ul><p>n – 布隆过滤器中元素的个数</p><p>p – 假阳率，在0-1之间 0.000000</p><p>m – 位图所占空间</p><p>k – hash函数的个数</p><p>公式如下：</p><p>n = ceil(m / (-k / log(1 - exp(log(p) / k))))</p><p>p = pow(1 - exp(-k / (m / n)), k)</p><p>m = ceil((n * log(p)) / log(1 / pow(2, log(2))));</p><p>k = round((m / n) * log(2));</p><ul><li><p>在实际应用中，我们确定n和p，通过公式计算得出m和k，也可以在网站上选取合适的值：<a href="https://hur.st/bloomfilter">https://hur.st/bloomfilter</a></p></li><li><p>n,p,m,k四个值之间的关系：</p><ol><li>m与k一定时，p与n成正相关</li><li>n与k一定时，p和m成负相关</li><li>n与m一定时，假阳率p会在某一特定的hash函数个数k取最小值，二者的关系近似一个二次函数的关系</li></ol></li><li><p>已知k，如何选择hash函数？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用双重hash的方法</span></span><br><span class="line"><span class="comment">//采用一个hash函数，给hash传不同的种子偏移值</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIX_UINT64(V)  ((uint32_t)((v&gt;&gt;32)^(v)))</span></span><br><span class="line"><span class="comment">//偏移32位</span></span><br><span class="line"><span class="keyword">uint64_t</span> hash1 = MurmurHash2_x64(key, len, Seed);</span><br><span class="line"><span class="keyword">uint64_t</span> hash2 = MurmurHash2_x64(key, len, MIX_UINT64(hash1));</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; k; i++) <span class="comment">// k 是hash函数的个数</span></span><br><span class="line">&#123;</span><br><span class="line"> Pos[i] = (hash1 + i*hash2) % m; <span class="comment">// m 是位图的⼤⼩</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过这种⽅式来模拟 k 个hash函数 跟我们前⾯开放寻址法 双重hash是⼀样的思路</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;面试经常问到的问题一：缓存穿透问题如何解决&quot;&gt;&lt;a href=&quot;#面试经常问到的问题一：缓存穿透问题如何解决&quot; class=&quot;headerlink&quot; title=&quot;面试经常问到的问题一：缓存穿透问题如何解决&quot;&gt;&lt;/a&gt;面试经常问到的问题一：缓存穿透问题如何解决&lt;/h3&gt;&lt;h4 id=&quot;什么是缓存穿透&quot;&gt;&lt;a href=&quot;#什么是缓存穿透&quot; class=&quot;headerlink&quot; title=&quot;什么是缓存穿透&quot;&gt;&lt;/a&gt;什么是缓存穿透&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;请求数据的时候，为了减轻落盘数据库(mysql)的访问压力，在server端与mysql之间加入一层缓冲数据层&lt;/li&gt;
&lt;li&gt;穿透场景发生在，redis,mysql中都没数据时，server端向数据库请求数据时，请求压力全部涌向落盘数据库(mysql)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;什么是数据请求步骤以及解决方法&quot;&gt;&lt;a href=&quot;#什么是数据请求步骤以及解决方法&quot; class=&quot;headerlink&quot; title=&quot;什么是数据请求步骤以及解决方法&quot;&gt;&lt;/a&gt;什么是数据请求步骤以及解决方法&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;/2021/03/25/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%8E%BB%E9%87%8Dhash%E4%B8%8E%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/image1.png&quot; alt=&quot;image-20210403120209067&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;需求&quot;&gt;&lt;a href=&quot;#需求&quot; class=&quot;headerlink&quot; title=&quot;需求&quot;&gt;&lt;/a&gt;需求&lt;/h3&gt;&lt;p&gt;从海量数据中查询某字符串是否存在&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://liangxiaocode.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="面试常问题" scheme="https://liangxiaocode.github.io/tags/%E9%9D%A2%E8%AF%95%E5%B8%B8%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>mysql底层面试必聊</title>
    <link href="https://liangxiaocode.github.io/2021/03/24/mysql%E5%BA%95%E5%B1%82%E9%9D%A2%E8%AF%95%E5%BF%85%E8%81%8A/"/>
    <id>https://liangxiaocode.github.io/2021/03/24/mysql%E5%BA%95%E5%B1%82%E9%9D%A2%E8%AF%95%E5%BF%85%E8%81%8A/</id>
    <published>2021-03-23T16:00:00.000Z</published>
    <updated>2021-04-03T04:15:32.352Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-谈一谈你对mysql索引的理解"><a href="#1-谈一谈你对mysql索引的理解" class="headerlink" title="1.谈一谈你对mysql索引的理解"></a>1.谈一谈你对mysql索引的理解</h1><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p><strong>索引的数据结构都是用的B+树</strong></p><p><strong>hash表也可以作为索引的数据结构，但存储引擎必须是memory，innodb存储引擎支持自适应hash，用户不可以干扰。</strong></p><p><strong>memory数据存储在内存中，断电后不可数据恢复。</strong></p><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><p>数据在磁盘上的不同组织形式</p><p><strong>innodb and myisam</strong></p><p>innodb:索引和数据是存储在一个文件中，支持事务和外键，支持表锁和行锁。</p><p>myisam:索引和数据存储在不同文件中，不支持事务和外键，只支持表锁。</p><span id="more"></span><h2 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="为什么mysql选择了B-树而不用其他数据结构"><a href="#为什么mysql选择了B-树而不用其他数据结构" class="headerlink" title="为什么mysql选择了B+树而不用其他数据结构"></a><strong>为什么mysql选择了B+树而不用其他数据结构</strong></h3><h4 id="1-hash表"><a href="#1-hash表" class="headerlink" title="1.hash表"></a>1.hash表</h4><ol><li>使用hash表必须要保证具备好的hash算法，如果hash算法选择不合适的话会造成hash冲突或者是hash碰撞，会导致数据散列不均匀，有可能会退化成一个链表。</li><li>使用hash表的时候不支持范围查询（模糊查询），当需要范围匹配的时候，必须要挨个对比，效率太低。</li><li>需要大量的内存空间。</li></ol><h4 id="2-二叉树、AVL、红黑树"><a href="#2-二叉树、AVL、红黑树" class="headerlink" title="2.二叉树、AVL、红黑树"></a>2.二叉树、AVL、红黑树</h4><ol><li>都是树。</li><li>分支有且仅有两个。</li><li>要存储更多的数据会导致树的层次加深，磁盘的I/O次数增多，导致查询效率降低。</li><li>因此要尽可能多的减少要读取的数据量，同时还要减少数据访问的次数。</li></ol><h1 id="2-B-树和B树的区别是什么"><a href="#2-B-树和B树的区别是什么" class="headerlink" title="2.B+树和B树的区别是什么"></a>2.B+树和B树的区别是什么</h1><ol><li>B+树磁盘读写代价更低。内部结点只包含索引列和key值，不包含数据，因此同样一个三层的B+树能够包含更多的数据。假设一页是16kb，B树中索引+key+value的值是1K,则一页只能存储16条数据，而三层就是16 * 16 * 16=4096条数据;由于B+树是把数据存储在叶子结点中，假设内部结点中索引+key=10Bytes，所以其内部结点中能够存放的个数近似为16*1000/10=1600。而三层就是1600 * 1600 * 16 = 40960000条数据，写入这样一次读入需要查找的关键字数量越多，I/O的次数就越低。</li><li>B+树查询效率更加稳定。所有数据的查询必须走一条从根结点到叶子结点的璐，所有关键字查询的路径长度相同，导致每一个数据查询的效率相当。而B树查询效率不固定，查询单条数据的时候，最好的情况是在根节点就能找到，O(1)的时间复杂度。因此，或许在做单一查找的时候B树平均效率会更高。而B+树虽然在做单一查询时时间复杂度比B树要慢，但是其查询速度很稳定，这与其数据只存在叶子结点这一关系是分不开的。</li><li>B+树更便于遍历。由于叶子结点上有指针进行连接，所以在做数据遍历的时候，只需要对叶子结点进行遍历扫描即可，因此该特性使得B+树非常时候做范围查找。而B树中内部结点同样存在数据，因此，在遍历的过程中，没有B+树那么方便。</li><li>B+树更适合做范围查找。B+树只需要去遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作或者说效率太低。</li></ol><h1 id="3-mysql聚簇索引和非聚簇索引的区别"><a href="#3-mysql聚簇索引和非聚簇索引的区别" class="headerlink" title="3.mysql聚簇索引和非聚簇索引的区别"></a>3.mysql聚簇索引和非聚簇索引的区别</h1><p>innodb存储引擎，在插入数据的时候，必须要将数据跟某一个索引列绑定到一起，索引列可以时主键，也可以是唯一键，也可以是6字节的rowid。、</p><hr><p>一个表中可以包含多个索引列，那么数据文件会存储几份？</p><p>数据仅仅只会存储一份，不会造成多份数据的数据冗余</p><hr><p>数据跟某一个索引列是绑定到一起的，那么其他索引列应该如何检索数据呢？</p><p>会将跟数据绑定到一起的索引列的值放到其他索引的叶子结点里。</p><!--假设跟数据绑定到一起的索引列是id,其他索引列是name,那么id的值会存储在name的叶子结点里--><hr><p>简单来说就是数据和索引放在一起的叫做聚簇索引，数据跟索引没有放在一起的叫做非聚簇索引</p><p>id:聚簇索引。name:非聚簇索引。<!--name里值存储了id，没有存储数据--></p><hr><p>在innodb存储引擎中，即存在聚簇索引，又存在非聚簇索引。</p><p>在myisam存储引擎中，只有非聚簇索引。</p><h1 id="4-使用mysql索引都有什么原则"><a href="#4-使用mysql索引都有什么原则" class="headerlink" title="4.使用mysql索引都有什么原则"></a>4.使用mysql索引都有什么原则</h1><h2 id="表：id-name-age-gender四个列，id-主键，-name-普通索引"><a href="#表：id-name-age-gender四个列，id-主键，-name-普通索引" class="headerlink" title="表：id,name,age,gender四个列，id 主键， name 普通索引"></a>表：id,name,age,gender四个列，id 主键， name 普通索引</h2><h3 id="回表"><a href="#回表" class="headerlink" title="回表"></a>回表</h3><p>select * from table where name = ‘zhangsan’——&gt;从某一个索引的叶子结点中获取聚簇索引的id值，再通过id值再去聚簇索引中获取全量记录。</p><h3 id="索引覆盖"><a href="#索引覆盖" class="headerlink" title="索引覆盖"></a>索引覆盖</h3><p>select id,name from table where name = ‘zhangsan’——&gt;从索引的叶子结点中能获取全量查询列的过程叫做索引覆盖。</p><h2 id="表：id-name-age-gender四个列，id-主键，-name-age是组合索引，先匹配最左的索引，即先匹配name再匹配age"><a href="#表：id-name-age-gender四个列，id-主键，-name-age是组合索引，先匹配最左的索引，即先匹配name再匹配age" class="headerlink" title="表：id,name,age,gender四个列，id 主键， name,age是组合索引，先匹配最左的索引，即先匹配name再匹配age"></a>表：id,name,age,gender四个列，id 主键， name,age是组合索引，先匹配最左的索引，即先匹配name再匹配age</h2><h3 id="最左匹配"><a href="#最左匹配" class="headerlink" title="最左匹配"></a>最左匹配</h3><ul><li>select * from where name = zhangsan and age = 10;</li><li>select * from where name = zhangsan;</li><li>select * from where age = 10;//当gender这一列不存在时，该语句也用到了组合索引</li><li>select * from where age = 10 and name = zhangsan ;</li></ul><p><strong>1,2,4可以使用组合索引，mysql优化器会进行优化，选择合适的顺序来执行。</strong></p><h3 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h3><ul><li>select * from table where name = shangsan;</li></ul><p>在没有索引下推之前，sql语句执行过程如下：先根据name去存储引擎拿到全量数据，再将数据读取到server层，然后在server层按照age过滤数据。</p><p>mysql 5.7 有了索引下推之后，直接根据name,age两个列去存储引擎筛选数据，将最终的结果返回给客户端。这样做减少了磁盘的I/O次数。</p><h1 id="5-mysql索引如何进行优化"><a href="#5-mysql索引如何进行优化" class="headerlink" title="5.mysql索引如何进行优化"></a>5.mysql索引如何进行优化</h1><p><strong><u>当表中的全部都是索引列的时候，无论进行什么样的查询都会用到索引</u></strong></p><p><strong><u>索引并不是越多越好，也不需要在全部列上添加索引</u></strong></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;1-谈一谈你对mysql索引的理解&quot;&gt;&lt;a href=&quot;#1-谈一谈你对mysql索引的理解&quot; class=&quot;headerlink&quot; title=&quot;1.谈一谈你对mysql索引的理解&quot;&gt;&lt;/a&gt;1.谈一谈你对mysql索引的理解&lt;/h1&gt;&lt;h3 id=&quot;数据结构&quot;&gt;&lt;a href=&quot;#数据结构&quot; class=&quot;headerlink&quot; title=&quot;数据结构&quot;&gt;&lt;/a&gt;数据结构&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;索引的数据结构都是用的B+树&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;hash表也可以作为索引的数据结构，但存储引擎必须是memory，innodb存储引擎支持自适应hash，用户不可以干扰。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;memory数据存储在内存中，断电后不可数据恢复。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;存储引擎&quot;&gt;&lt;a href=&quot;#存储引擎&quot; class=&quot;headerlink&quot; title=&quot;存储引擎&quot;&gt;&lt;/a&gt;存储引擎&lt;/h2&gt;&lt;p&gt;数据在磁盘上的不同组织形式&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;innodb and myisam&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;innodb:索引和数据是存储在一个文件中，支持事务和外键，支持表锁和行锁。&lt;/p&gt;
&lt;p&gt;myisam:索引和数据存储在不同文件中，不支持事务和外键，只支持表锁。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://liangxiaocode.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="面试常问题" scheme="https://liangxiaocode.github.io/tags/%E9%9D%A2%E8%AF%95%E5%B8%B8%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>磁盘存储链式的B树与B+树</title>
    <link href="https://liangxiaocode.github.io/2021/03/23/%E7%A3%81%E7%9B%98%E5%AD%98%E5%82%A8%E9%93%BE%E5%BC%8F%E7%9A%84B%E6%A0%91%E4%B8%8EB+%E6%A0%91/"/>
    <id>https://liangxiaocode.github.io/2021/03/23/%E7%A3%81%E7%9B%98%E5%AD%98%E5%82%A8%E9%93%BE%E5%BC%8F%E7%9A%84B%E6%A0%91%E4%B8%8EB+%E6%A0%91/</id>
    <published>2021-03-22T16:00:00.000Z</published>
    <updated>2021-04-02T03:48:45.716Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么磁盘的读写比内存慢"><a href="#为什么磁盘的读写比内存慢" class="headerlink" title="为什么磁盘的读写比内存慢"></a>为什么磁盘的读写比内存慢</h2><p>​        内存是CPU直接通过总线访问的，它是用来储存CPU常用数据的。CPU会频繁的访问内存，所以内存必须拥有足够高的读写速度，才不会成为系统性能的瓶颈。</p><p>​        硬盘是通过串行的方式访问的，它的用途就是永久性的储存数据，速度快不快，一定程度上对系统性能的影响不像内存那么明显。当CPU想要访问硬盘中的数据，只能先把他们读到内存中，也就是加载到内存，然后CPU再访问内存以达到读取数据的目的。加载到内存的过程中，是磁盘再寻址的过程，的确，磁盘的慢就是慢在寻址的过程。</p><p>​        假设红黑树有1024个节点，总共有十层的数据，CPU最差需要通过十次才能拿到想要的数据。因此我们需要引用多叉树，或者说多叉树被常常用在磁盘的存储中。</p><span id="more"></span><h2 id="B-树"><a href="#B-树" class="headerlink" title="B-树"></a>B-树</h2><h3 id="B-树的性质"><a href="#B-树的性质" class="headerlink" title="B-树的性质"></a>B-树的性质</h3><h4 id="一颗M阶B树T，满足以下条件"><a href="#一颗M阶B树T，满足以下条件" class="headerlink" title="一颗M阶B树T，满足以下条件"></a>一颗M阶B树T，满足以下条件</h4><ul><li>每个结点至多拥有M颗子树</li><li>根结点至少拥有两颗子树</li><li>除了根结点以外，其余每个分支结点至少拥有M/2颗子树</li><li>所有的叶结点都在同一层上</li><li>有K颗子树的分支结点则存在K-1个关键字，关键字按照递增顺序</li><li>关键字数量满足ceil(M/2)-1&lt;=n&lt;=M-1</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义B树</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> KEY_VALUE;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">btree_node</span>&#123;</span></span><br><span class="line"></span><br><span class="line">KEY_VALUE *key;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">btree_node</span> **<span class="title">children</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num; <span class="comment">//关键字</span></span><br><span class="line"><span class="keyword">int</span> leaf;<span class="comment">//叶子结点</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">btree</span>&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">btree_node</span> *<span class="title">root</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="B树的添加"><a href="#B树的添加" class="headerlink" title="B树的添加"></a>B树的添加</h3><h4 id="二十六个字母为例实现添加的过程"><a href="#二十六个字母为例实现添加的过程" class="headerlink" title="二十六个字母为例实现添加的过程"></a>二十六个字母为例实现添加的过程</h4><p>在添加key的时候</p><p>分裂有两种情况：</p><ol><li>​    只有根节点的时候，一个结点分裂为三个结点</li><li>其余情况，一个结点分裂为两个结点</li></ol><p>插入的时候，两个步骤：</p><ol><li>​    找到对应的结点</li><li>对结点的key对比没找到合适的位置</li></ol><p>插入的结点就是插在叶子结点上面</p><h3 id="B树的删除"><a href="#B树的删除" class="headerlink" title="B树的删除"></a>B树的删除</h3><p>待更新。。</p><h2 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+树"></a>B+树</h2><p>待更新。。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;为什么磁盘的读写比内存慢&quot;&gt;&lt;a href=&quot;#为什么磁盘的读写比内存慢&quot; class=&quot;headerlink&quot; title=&quot;为什么磁盘的读写比内存慢&quot;&gt;&lt;/a&gt;为什么磁盘的读写比内存慢&lt;/h2&gt;&lt;p&gt;​        内存是CPU直接通过总线访问的，它是用来储存CPU常用数据的。CPU会频繁的访问内存，所以内存必须拥有足够高的读写速度，才不会成为系统性能的瓶颈。&lt;/p&gt;
&lt;p&gt;​        硬盘是通过串行的方式访问的，它的用途就是永久性的储存数据，速度快不快，一定程度上对系统性能的影响不像内存那么明显。当CPU想要访问硬盘中的数据，只能先把他们读到内存中，也就是加载到内存，然后CPU再访问内存以达到读取数据的目的。加载到内存的过程中，是磁盘再寻址的过程，的确，磁盘的慢就是慢在寻址的过程。&lt;/p&gt;
&lt;p&gt;​        假设红黑树有1024个节点，总共有十层的数据，CPU最差需要通过十次才能拿到想要的数据。因此我们需要引用多叉树，或者说多叉树被常常用在磁盘的存储中。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://liangxiaocode.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>二叉树与红黑树</title>
    <link href="https://liangxiaocode.github.io/2021/03/22/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%8E%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    <id>https://liangxiaocode.github.io/2021/03/22/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%8E%E7%BA%A2%E9%BB%91%E6%A0%91/</id>
    <published>2021-03-21T16:00:00.000Z</published>
    <updated>2021-04-02T03:46:21.442Z</updated>
    
    <content type="html"><![CDATA[<h2 id="浅谈二叉树"><a href="#浅谈二叉树" class="headerlink" title="浅谈二叉树"></a>浅谈二叉树</h2><h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><p>二叉树是一种特殊的树结构，在二叉树中每个结点最多只能由两个子结点。除了根结点外每个结点只有一个父结点，根结点没有父结点。在二叉树中最常见的就是二叉树的遍历，即按照某一顺序访问树中的所有结点。以下面二叉树为例，来看一下二叉树的遍历方式：</p><p><img src="/2021/03/22/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%8E%E7%BA%A2%E9%BB%91%E6%A0%91/bin_tree.png"></p><span id="more"></span><p>1.前序遍历：先访问根结点，再访问左子结点，最后访问右子结点</p><p>前序遍历的顺序为：14，8，5，10，20，16，26</p><p>2.中序遍历：先访问左子结点，再访问根结点，最后访问右子结点</p><p>中序遍历的顺序为：5，8，10，14，16，20，26</p><p>3.后序遍历：先访问左子结点，再访问右子结点，最后访问根结点</p><p>后序遍历的顺序为：5，10，8，16，26，20，14</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉树的递归遍历</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bstree_traversal</span><span class="params">(struct bstree_node *node)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (node == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// printf(&quot;%4d &quot;,node-&gt;data);前序遍历</span></span><br><span class="line">bstree_traversal(node-&gt;bst.left);</span><br><span class="line"><span class="comment">// printf(&quot;%4d &quot;,node-&gt;data);中序遍历</span></span><br><span class="line">bstree_traversal(node-&gt;bst.right);</span><br><span class="line"><span class="comment">// printf(&quot;%4d &quot;,node-&gt;data);后序遍历</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树为什么常用？"><a href="#二叉树为什么常用？" class="headerlink" title="二叉树为什么常用？"></a>二叉树为什么常用？</h3><p>​        1.二叉树以key-&gt;value来进行查找，十分便利。</p><p>​        2.通过中序遍历。</p><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><h3 id="红黑树的性质"><a href="#红黑树的性质" class="headerlink" title="红黑树的性质"></a>红黑树的性质</h3><ul><li>每个结点是红的或是黑的</li><li>根结点是黑的</li><li>每个叶子结点是黑的</li><li><u>如果每个结点是红的，则它的两个儿子都是黑的</u></li><li><u>对每个结点，从该结点到其子孙结点的所有路劲上包含相同数目的黑结点，即黑高相同。</u></li><li>所有叶子结点都隐藏，并且为黑色。</li></ul><h3 id="红黑数的应用"><a href="#红黑数的应用" class="headerlink" title="红黑数的应用"></a>红黑数的应用</h3><ul><li>L进程调度CFS</li><li>Nginx Timer事件管理</li><li>Epoll事件块的管理</li></ul><h3 id="红黑数的左右旋"><a href="#红黑数的左右旋" class="headerlink" title="红黑数的左右旋"></a>红黑数的左右旋</h3><p>什么是红黑数的左右旋？见下图：</p><p><img src="/2021/03/22/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%8E%E7%BA%A2%E9%BB%91%E6%A0%91/rbtree_rotate.png" alt="rbtree_rotate"></p><p>因此，这里需要考虑的是三对指针之间的变化。对于左旋，考虑的是x与parent之间的两条指针，x与b之间的两条指针以及x与y之间的两条指针的转变。而右旋则刚好相反。所以我们可以写出下列代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int KEY_VALUE;</span></span><br><span class="line"><span class="comment">//先定义红黑树</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">rbtree_node</span>&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> color;</span><br><span class="line">rbtree_node *left;</span><br><span class="line">rbtree_node *right;</span><br><span class="line">rbtree_node *parent;</span><br><span class="line"></span><br><span class="line">KEY_VALUE key;</span><br><span class="line"><span class="keyword">void</span> *value;</span><br><span class="line"></span><br><span class="line">&#125;rbtree_node;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">rbtree</span>&#123;</span></span><br><span class="line"></span><br><span class="line">rbtree_node *root;</span><br><span class="line">rbtree_node *null;<span class="comment">//叶子结点隐藏，全部为黑色</span></span><br><span class="line"></span><br><span class="line">&#125;rbtree;</span><br><span class="line"><span class="comment">//左旋算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rbtree_left_rotate</span><span class="params">(rbtree *T,rbtree_node *x)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(x == T-&gt;null) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">rbtree *y = x-&gt;right;</span><br><span class="line"></span><br><span class="line">x-&gt;right = y-&gt;left;</span><br><span class="line"><span class="keyword">if</span>(y-&gt;left!=T-&gt;null)&#123;</span><br><span class="line">y-&gt;left-&gt;parent = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">y-&gt;parent = x-&gt;parent;</span><br><span class="line"><span class="keyword">if</span>(x-&gt;parent=T-&gt;null)&#123;</span><br><span class="line">T-&gt;root=y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(x==x-&gt;parent-&gt;left)&#123;</span><br><span class="line">x-&gt;parent-&gt;left=y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">x-&gt;parent-&gt;right=y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">y-&gt;left = x;</span><br><span class="line">x-&gt;parent = y;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>右旋算法恰好与左旋相反，将x-&gt;y,y-&gt;x;left-&gt;right,right-&gt;left即可。</p><h3 id="红黑树的插入"><a href="#红黑树的插入" class="headerlink" title="红黑树的插入"></a>红黑树的插入</h3><p>红黑树的插入与二叉树的插入大同小异，满足中序遍历。但是在插入一个结点以前，其本身就是一个红黑数，因此再插入这个结点的颜色，是红色更容易满足红黑树的性质。当插入结点为红色时，性质四比较容易违背，即当前结点是红色且<u>父结点也是红色</u>这条性质容易违背，此时需要作出调整。</p><p>假设我们插入结点的父结点是祖父结点的左子树的情况：</p><ol><li>叔父结点是红色的</li><li>叔父结点是黑色，而且当前结点是右孩子</li><li>叔父结点是黑色，而且当前结点是左孩子</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rbtree_insert_fixup</span><span class="params">(rbtree *T,rbtree_node *ins)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ins-&gt;color 一直为红色</span></span><br><span class="line"><span class="keyword">while</span>(ins-&gt;parent == RED)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(ins-&gt;parent = ins-&gt;parent-&gt;parent&gt;left)&#123;</span><br><span class="line">rbtree_node *unclenode = ins-&gt;parent-&gt;parent-&gt;right;</span><br><span class="line">            <span class="comment">//第1种情况</span></span><br><span class="line"><span class="keyword">if</span>(unclenode-&gt;color == RED)&#123;</span><br><span class="line">y-&gt;color = BLACK;</span><br><span class="line">ins-&gt;parent-&gt;color = BLACK;</span><br><span class="line">ins = ins-&gt;parent-&gt;parent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//第2种情况，右孩子时需要先对其父结点进行一个左旋</span></span><br><span class="line"><span class="keyword">if</span>(ins = ins-&gt;parent-&gt;right)&#123;</span><br><span class="line">ins = ins-&gt;parent;</span><br><span class="line">rbtree_left_rotate(T,ins);</span><br><span class="line">&#125;</span><br><span class="line">             <span class="comment">//第3种情况</span></span><br><span class="line">ins-&gt;parent-&gt;color = BLACK;</span><br><span class="line">ins-&gt;parent-&gt;parent-&gt;color = RED;</span><br><span class="line">rbtree_right_rotate(T,ins-&gt;parent-&gt;parent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;<span class="comment">//else表示当前插入结点的父结点是祖父结点的右子树的情况时，所有的操作和上面的情况反过来，即left-&gt;right,right-&gt;left</span></span><br><span class="line">rbtree_node *unclenode = ins-&gt;parent-&gt;parent-&gt;left;</span><br><span class="line"><span class="keyword">if</span>(unclenode-&gt;color == RED)&#123;</span><br><span class="line">y-&gt;color = BLACK;</span><br><span class="line">ins-&gt;parent-&gt;color = BLACK;</span><br><span class="line">ins = ins-&gt;parent-&gt;parent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(ins = ins-&gt;parent-&gt;left)&#123;</span><br><span class="line">ins = ins-&gt;parent;</span><br><span class="line">rbtree_right_rotate(T,ins);</span><br><span class="line">&#125;</span><br><span class="line">ins-&gt;parent-&gt;color = BLACK;</span><br><span class="line">ins-&gt;parent-&gt;parent-&gt;color = RED;</span><br><span class="line">rbtree_left_rotate(T,ins-&gt;parent-&gt;parent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">T-&gt;root-&gt;color = BLACK;<span class="comment">//根结点必须是黑色的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="红黑树的删除"><a href="#红黑树的删除" class="headerlink" title="红黑树的删除"></a>红黑树的删除</h3><p> 待更新。。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;浅谈二叉树&quot;&gt;&lt;a href=&quot;#浅谈二叉树&quot; class=&quot;headerlink&quot; title=&quot;浅谈二叉树&quot;&gt;&lt;/a&gt;浅谈二叉树&lt;/h2&gt;&lt;h3 id=&quot;二叉树的遍历&quot;&gt;&lt;a href=&quot;#二叉树的遍历&quot; class=&quot;headerlink&quot; title=&quot;二叉树的遍历&quot;&gt;&lt;/a&gt;二叉树的遍历&lt;/h3&gt;&lt;p&gt;二叉树是一种特殊的树结构，在二叉树中每个结点最多只能由两个子结点。除了根结点外每个结点只有一个父结点，根结点没有父结点。在二叉树中最常见的就是二叉树的遍历，即按照某一顺序访问树中的所有结点。以下面二叉树为例，来看一下二叉树的遍历方式：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2021/03/22/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%8E%E7%BA%A2%E9%BB%91%E6%A0%91/bin_tree.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://liangxiaocode.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>面试必聊的排序与KMP算法</title>
    <link href="https://liangxiaocode.github.io/2021/03/21/%E9%9D%A2%E8%AF%95%E5%BF%85%E8%81%8A%E7%9A%84%E6%8E%92%E5%BA%8F%E4%B8%8EKMP%E7%AE%97%E6%B3%95/"/>
    <id>https://liangxiaocode.github.io/2021/03/21/%E9%9D%A2%E8%AF%95%E5%BF%85%E8%81%8A%E7%9A%84%E6%8E%92%E5%BA%8F%E4%B8%8EKMP%E7%AE%97%E6%B3%95/</id>
    <published>2021-03-20T16:00:00.000Z</published>
    <updated>2021-05-06T10:53:12.609Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、常见排序算法的时间与空间复杂度问题"><a href="#一、常见排序算法的时间与空间复杂度问题" class="headerlink" title="一、常见排序算法的时间与空间复杂度问题"></a>一、常见排序算法的时间与空间复杂度问题</h2><table><thead><tr><th align="center">排序算法</th><th align="center">平均时间复杂度</th><th align="center">最好情况</th><th align="center">最坏情况</th><th align="center">空间复杂度</th></tr></thead><tbody><tr><td align="center">冒泡排序</td><td align="center">O(N*N)</td><td align="center">O(N)</td><td align="center">O(N*N)</td><td align="center">O(1)</td></tr><tr><td align="center">选择排序</td><td align="center">O(N*N)</td><td align="center">O(N*N)</td><td align="center">O(N*N)</td><td align="center">O(1)</td></tr><tr><td align="center">插入排序</td><td align="center">O(N*N)</td><td align="center">O(N)</td><td align="center">O(N*N)</td><td align="center">O(1)</td></tr><tr><td align="center">希尔排序</td><td align="center">O(N^1.3)</td><td align="center">O(N)</td><td align="center">O(N*N)</td><td align="center">O(1)</td></tr><tr><td align="center">归并排序</td><td align="center">O(N log N)</td><td align="center">O(N log N)</td><td align="center">O(N)</td><td align="center">O(N)</td></tr><tr><td align="center">快速排序</td><td align="center">O(N log N)</td><td align="center">O(N log N)</td><td align="center">O(N*N)</td><td align="center">O(log N)</td></tr></tbody></table><p>​        相信我们对前三种排序方法很了解(在大学里或多或少都有写过相应的代码)，今天主要是简单聊一下希尔排序和快速排序排序算法。</p><span id="more"></span><h3 id="1-希尔排序"><a href="#1-希尔排序" class="headerlink" title="1.希尔排序"></a>1.希尔排序</h3><p>分组的思想：每一次循环设置一个增量，初值addtion=length/2，循环令addtion=addtion/2。直到addtion&lt;1。然后对二层循环对组内进行排序。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shell_sort</span><span class="params">(<span class="keyword">int</span> *data,<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>,j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> addtion = <span class="number">0</span>;<span class="comment">// 增量</span></span><br><span class="line"><span class="keyword">for</span>(addtion = length/<span class="number">2</span>;addtion &gt;= <span class="number">1</span>;addtion /= <span class="number">2</span>)&#123;<span class="comment">//分成多少组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i = addtion; i &lt; length;i++)&#123;<span class="comment">//组内遍历</span></span><br><span class="line"><span class="keyword">int</span> temp = data[i];</span><br><span class="line"><span class="keyword">for</span>(j = i - addtion;j&gt;=<span class="number">0</span>&amp;&amp;temp&lt;data[j];j = j-addtion)&#123;<span class="comment">//组内排序</span></span><br><span class="line"></span><br><span class="line">data[j+addtion] = data[j]</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">data[j+addtion] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-快速排序"><a href="#2-快速排序" class="headerlink" title="2.快速排序"></a>2.快速排序</h3><p>递归思想：第一个值data[i=0]作为哨兵的话，从最后面data[size = j–]往前面找，找到第一个比他小，两者交换，保存当前j位置。再data[i++]，找寻比data[j]大的值，两者交换，保存当前i的位置。再重复上面的操作，直到i=j。形成左右两个[0,i-1]和[j+1,size]集合再进行递归操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qsort</span><span class="params">(<span class="keyword">int</span> *data,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(left&gt;=right) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i=left;</span><br><span class="line"><span class="keyword">int</span> j=right;q</span><br><span class="line"><span class="keyword">int</span> key=data[i];<span class="comment">//key代表哨兵</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(i&lt;j&amp;&amp;key&lt;data[j])<span class="comment">//从后往左，j--,这里的i&lt;j可以去掉</span></span><br><span class="line">--j;</span><br><span class="line">data[i] = data[j];</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(i&lt;j&amp;&amp;key&gt;=data[i]) <span class="comment">//从前往后，i++，而这里的i&lt;j不可以去掉，思考一下为什么？</span></span><br><span class="line">++i;</span><br><span class="line">data[j]=data[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// if(i==j)</span></span><br><span class="line">data[i] = key;</span><br><span class="line"><span class="comment">//递归调用</span></span><br><span class="line">sort(data,left,i<span class="number">-1</span>);</span><br><span class="line">sort(data,i+<span class="number">1</span>,right);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-归并排序"><a href="#3-归并排序" class="headerlink" title="3.归并排序"></a>3.归并排序</h3><p>递归思想：1、将n个元素分成含n/2个元素的子序列；2、用合并排序法对两个子序列递归的排序；3、不断合并两个已排序的子序列直到所有元素排序完毕。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_recursive_sort</span><span class="params">(<span class="keyword">int</span> *data,<span class="keyword">int</span> *sortresult,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(start == end)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> len = end-start,mid = len/<span class="number">2</span>+start;c</span><br><span class="line"><span class="keyword">int</span> start1 = start,end1 = mid;</span><br><span class="line"><span class="keyword">int</span> start2 = mid+<span class="number">1</span>;end2 = end;、</span><br><span class="line">    <span class="comment">//分割</span></span><br><span class="line">merge_recursive_sort(data,sortresult,start1,end1);</span><br><span class="line">merge_recursive_sort(data,sortresult,start2,end2);</span><br><span class="line">k = start;</span><br><span class="line">    <span class="comment">//递归排序</span></span><br><span class="line"><span class="keyword">while</span>(start1&lt;=end1&amp;&amp;start2&lt;=end2)&#123;</span><br><span class="line">sortresult[k++] = data[start1]&lt;data[start2]?data[start1++]:data[start2++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(start1&lt;=end1)&#123;</span><br><span class="line">sortresult[k++]=data[star1++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(start2&lt;end2)&#123;</span><br><span class="line">sortresult[k++]=data[start2++];</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//合并</span></span><br><span class="line"><span class="keyword">for</span>(k = start;k&lt;=end;k++)&#123;</span><br><span class="line">data[k]=sortresult[k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、浅谈KMP算法"><a href="#二、浅谈KMP算法" class="headerlink" title="二、浅谈KMP算法"></a>二、浅谈KMP算法</h2><p>废话不多说直接上核心代码~~~</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//KMP算法第一步</span></span><br><span class="line"><span class="comment">//得到next数组</span></span><br><span class="line"><span class="comment">//什么是前缀、后缀</span></span><br><span class="line"><span class="comment">//对于一个字符串来说</span></span><br><span class="line"><span class="comment">//除了第一个字符，剩下的从后往前的字符可以称作后缀</span></span><br><span class="line"><span class="comment">//除了最后一个字符，剩下的从前往后的字符可以称作前缀</span></span><br><span class="line"><span class="comment">//例如：abcabc</span></span><br><span class="line"><span class="comment">//前缀：a,ab,abc,abca,abcab</span></span><br><span class="line"><span class="comment">//后缀：c,bc,abc,cabc,bcabc</span></span><br><span class="line"><span class="comment">//next数组：000123</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make_next</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pattern, <span class="keyword">int</span> *next)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> q, k;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="built_in">strlen</span>(pattern);</span><br><span class="line"></span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// </span></span><br><span class="line">    <span class="keyword">for</span> (q = <span class="number">1</span>,k = <span class="number">0</span>;q &lt; m; q ++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">0</span> &amp;&amp; pattern[q] != pattern[k]) &#123;</span><br><span class="line">            k = next[k<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pattern[q] == pattern[k]) &#123;<span class="comment">//当前缀与后缀有相同的字符</span></span><br><span class="line">            k ++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        next[q] = k;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *text, <span class="keyword">const</span> <span class="keyword">char</span> *pattern, <span class="keyword">int</span> *next)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(text);</span><br><span class="line">    <span class="keyword">int</span> m = <span class="built_in">strlen</span>(pattern);</span><br><span class="line"></span><br><span class="line">    make_next(pattern, next);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i, q;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, q = <span class="number">0</span>;i &lt; n;i ++) &#123; <span class="comment">//i是text的当前位置, q是pattern的当前位置</span></span><br><span class="line">        <span class="keyword">while</span> (q &gt; <span class="number">0</span> &amp;&amp; pattern[q] != text[i]) &#123;</span><br><span class="line">            q = next[q<span class="number">-1</span>];</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span> (pattern[q] == text[i]) &#123;</span><br><span class="line">            q ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// q == m ---&gt;  </span></span><br><span class="line">        <span class="keyword">if</span> (q == m) &#123;</span><br><span class="line">            <span class="keyword">return</span> i-q+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、面试容易问到的链表问题"><a href="#三、面试容易问到的链表问题" class="headerlink" title="三、面试容易问到的链表问题"></a>三、面试容易问到的链表问题</h2><h2 id="死背也要记住"><a href="#死背也要记住" class="headerlink" title="(死背也要记住)"></a>(死背也要记住)</h2><h3 id="0-单向链表中如何找到到数第N个结点"><a href="#0-单向链表中如何找到到数第N个结点" class="headerlink" title="0.单向链表中如何找到到数第N个结点"></a>0.单向链表中如何找到到数第N个结点</h3><p>快慢指针的思想：快的指针比慢指针多走了N个结点，直到快指针 = NULL时，慢指针所指向的结点就是倒数第N个结点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct list_node* <span class="title">find_lastNnode</span><span class="params">(struct list_node *head,<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_node</span> *<span class="title">fast</span> =</span> head;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_node</span> *<span class="title">slow</span> =</span> head;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line"></span><br><span class="line">fast = fast-&gt;next;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(fast)&#123;</span><br><span class="line"></span><br><span class="line">fast = fast-&gt;next;</span><br><span class="line">slow = slow-&gt;next;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-判断链表有没有环"><a href="#1-判断链表有没有环" class="headerlink" title="1.判断链表有没有环"></a>1.判断链表有没有环</h3><p>也是快慢指针：point1 += 1,point += 2,一直往前走，如果当point1 = point2时，则说明存在环，否则point1 = point2 = NULL时则没有环。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> list_node *<span class="title">is_loop</span><span class="params">(struct list_node *head)</span></span>&#123;</span><br><span class="line"><span class="comment">//返回的是环的长度，如果没有就返回0</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_node</span> *<span class="title">fastpointer</span> =</span> *slowpointer = head;</span><br><span class="line"><span class="keyword">int</span> looplength = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> begincount = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(fastpointer-&gt;next!=<span class="literal">NULL</span>&amp;&amp;fastpointer-&gt;next-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line"></span><br><span class="line">slowpointer = slowpointer-&gt;next;</span><br><span class="line">fastpointer = fastpointer-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一次相遇时开始计数</span></span><br><span class="line">        <span class="keyword">if</span>(slowpointer==fastpointer &amp;&amp; begincount == <span class="literal">false</span>)&#123;</span><br><span class="line">            begincount = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">if</span>(beginecount == <span class="literal">true</span>)&#123;</span><br><span class="line">            ++looplength;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第二次相遇时跳出循环</span></span><br><span class="line">        <span class="keyword">if</span>(slowpointer==fastpointer &amp;&amp; begincount == <span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> looplength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-判断两个链表是否存在公共结点"><a href="#2-判断两个链表是否存在公共结点" class="headerlink" title="2.判断两个链表是否存在公共结点"></a>2.判断两个链表是否存在公共结点</h3><p>还是快慢指针的思想：先得到两个链表的长度A和B（假设A&gt;B），再让长的链表的指针指向第A-B+1的位置，对二者分别进行步长为1的遍历，直到找到相等的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_common_node</span><span class="params">(struct list_node *head1,struct list_node *head2)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head1length = head2length = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(struct list_node *current=head1;current!=<span class="literal">NULL</span>;current=current-&gt;next)</span><br><span class="line">++head1length;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(struct list_node *current=head2;current!=<span class="literal">NULL</span>;current=current-&gt;next)</span><br><span class="line">++head2length;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_node</span> *<span class="title">current1</span> =</span> head1;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_node</span> *<span class="title">current2</span> =</span> head2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(head1length&gt;head2length)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;head1length-head2length;i++)&#123;</span><br><span class="line"></span><br><span class="line">current1 = current1-&gt;next;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;head2length-head1length;i++)&#123;</span><br><span class="line"></span><br><span class="line">current2 = current2-&gt;next;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(current1)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(current1 == current2)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">current1=current1-&gt;next;</span><br><span class="line">current2=current2-&gt;next;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-链表的反转问题"><a href="#3-链表的反转问题" class="headerlink" title="3.链表的反转问题"></a>3.链表的反转问题</h3><p>三个指针，prev,current,next,断开current于next的连接，将current-&gt;next = prev,再将prev往后移一个结点，current往后移一个结点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct list_node* <span class="title">reverse_list</span><span class="params">(struct list_node *head)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_node</span> *<span class="title">prev</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_node</span> *<span class="title">current</span> =</span> head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (current) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_node</span> *<span class="title">node</span> =</span> current -&gt;next;</span><br><span class="line">        current-&gt;next = prev;</span><br><span class="line">        prev = current;</span><br><span class="line">        current = node;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一、常见排序算法的时间与空间复杂度问题&quot;&gt;&lt;a href=&quot;#一、常见排序算法的时间与空间复杂度问题&quot; class=&quot;headerlink&quot; title=&quot;一、常见排序算法的时间与空间复杂度问题&quot;&gt;&lt;/a&gt;一、常见排序算法的时间与空间复杂度问题&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;排序算法&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;平均时间复杂度&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;最好情况&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;最坏情况&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;空间复杂度&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;冒泡排序&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;O(N*N)&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;O(N)&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;O(N*N)&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;选择排序&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;O(N*N)&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;O(N*N)&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;O(N*N)&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;插入排序&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;O(N*N)&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;O(N)&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;O(N*N)&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;希尔排序&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;O(N^1.3)&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;O(N)&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;O(N*N)&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;归并排序&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;O(N log N)&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;O(N log N)&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;O(N)&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;O(N)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;快速排序&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;O(N log N)&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;O(N log N)&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;O(N*N)&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;O(log N)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;​        相信我们对前三种排序方法很了解(在大学里或多或少都有写过相应的代码)，今天主要是简单聊一下希尔排序和快速排序排序算法。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://liangxiaocode.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="面试常问题" scheme="https://liangxiaocode.github.io/tags/%E9%9D%A2%E8%AF%95%E5%B8%B8%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Image Test</title>
    <link href="https://liangxiaocode.github.io/2021/03/20/images/"/>
    <id>https://liangxiaocode.github.io/2021/03/20/images/</id>
    <published>2021-03-20T02:10:04.000Z</published>
    <updated>2021-04-01T11:23:43.913Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2021/03/20/images/aaa.jpg" alt="liangxiao"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2021/03/20/images/aaa.jpg&quot; alt=&quot;liangxiao&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="images" scheme="https://liangxiaocode.github.io/tags/images/"/>
    
  </entry>
  
  <entry>
    <title>一个小姐姐的markdown例子</title>
    <link href="https://liangxiaocode.github.io/2021/03/20/%E4%B8%80%E4%B8%AA%E5%B0%8F%E5%A7%90%E5%A7%90%E7%9A%84markdown%E4%BE%8B%E5%AD%90/"/>
    <id>https://liangxiaocode.github.io/2021/03/20/%E4%B8%80%E4%B8%AA%E5%B0%8F%E5%A7%90%E5%A7%90%E7%9A%84markdown%E4%BE%8B%E5%AD%90/</id>
    <published>2021-03-20T01:48:23.000Z</published>
    <updated>2021-04-02T03:04:48.038Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><p>==字体==</p><p><strong>加粗</strong></p><p><em>斜体</em></p><p><em><strong>斜体加粗</strong></em></p><p><del>删除线</del></p><p>==高亮==</p><span id="more"></span><p>我是^上标^<br>我是<del>下标</del></p><p>==(3)列表==</p><ul><li><p>一二三四五</p><ul><li><p>上山打老虎</p><ul><li><p>老虎没打到</p><pre><code>+ 打到小松鼠</code></pre></li></ul></li></ul></li></ul><ol><li><p>一二三四五</p></li><li><p>上山打老虎</p></li><li><p>老虎没打到</p></li><li><p>打到小松鼠</p></li></ol><p>==(4)表格==</p><p>| Mon    | TUE    | WED    | THU    | FRI    |</p><p>| —— | —— | —— | —— | —— |</p><p>| 上山   | 上山   | 上山   | 上山   | 上山   |</p><p>| 打老虎 | 打老虎 | 打老虎 | 打老虎 | 打老虎 |</p><p>==(5)引用==</p><blockquote><p>一二三四五</p></blockquote><blockquote><blockquote><p>上山打老虎</p></blockquote></blockquote><blockquote><blockquote><blockquote><p>老虎没打到</p></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><p>打到小松鼠</p></blockquote></blockquote></blockquote></blockquote><p>==(6)分割线==</p><hr><p>==(7)代码==</p><p><code>我是代码</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我是代码框</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a markdown example\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>作者：你的乖女儿不乖<br><a href="https://www.bilibili.com/read/cv6491991?spm_id_from=333.788.b_636f6d6d656e74.6">https://www.bilibili.com/read/cv6491991?spm_id_from=333.788.b_636f6d6d656e74.6</a><br>出处： bilibili</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一级标题&quot;&gt;&lt;a href=&quot;#一级标题&quot; class=&quot;headerlink&quot; title=&quot;一级标题&quot;&gt;&lt;/a&gt;一级标题&lt;/h1&gt;&lt;h2 id=&quot;二级标题&quot;&gt;&lt;a href=&quot;#二级标题&quot; class=&quot;headerlink&quot; title=&quot;二级标题&quot;&gt;&lt;/a&gt;二级标题&lt;/h2&gt;&lt;h3 id=&quot;三级标题&quot;&gt;&lt;a href=&quot;#三级标题&quot; class=&quot;headerlink&quot; title=&quot;三级标题&quot;&gt;&lt;/a&gt;三级标题&lt;/h3&gt;&lt;h4 id=&quot;四级标题&quot;&gt;&lt;a href=&quot;#四级标题&quot; class=&quot;headerlink&quot; title=&quot;四级标题&quot;&gt;&lt;/a&gt;四级标题&lt;/h4&gt;&lt;h5 id=&quot;五级标题&quot;&gt;&lt;a href=&quot;#五级标题&quot; class=&quot;headerlink&quot; title=&quot;五级标题&quot;&gt;&lt;/a&gt;五级标题&lt;/h5&gt;&lt;h6 id=&quot;六级标题&quot;&gt;&lt;a href=&quot;#六级标题&quot; class=&quot;headerlink&quot; title=&quot;六级标题&quot;&gt;&lt;/a&gt;六级标题&lt;/h6&gt;&lt;p&gt;==字体==&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;加粗&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;斜体&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;斜体加粗&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;del&gt;删除线&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;==高亮==&lt;/p&gt;</summary>
    
    
    
    <category term="hexo_example" scheme="https://liangxiaocode.github.io/categories/hexo-example/"/>
    
    
  </entry>
  
  <entry>
    <title>My new blog</title>
    <link href="https://liangxiaocode.github.io/2021/03/19/My-new-blog/"/>
    <id>https://liangxiaocode.github.io/2021/03/19/My-new-blog/</id>
    <published>2021-03-19T11:14:07.000Z</published>
    <updated>2021-04-01T11:15:26.336Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><p>内容1</p><p>内容2</p><span id="more"></span><h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><p>内容3</p><p>内容4</p><p>内容5</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="http://www.liangxiaocode.cn---/">www.liangxiaocode.cn---</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;第一章&quot;&gt;&lt;a href=&quot;#第一章&quot; class=&quot;headerlink&quot; title=&quot;第一章&quot;&gt;&lt;/a&gt;第一章&lt;/h2&gt;&lt;p&gt;内容1&lt;/p&gt;
&lt;p&gt;内容2&lt;/p&gt;</summary>
    
    
    
    <category term="hexo_example" scheme="https://liangxiaocode.github.io/categories/hexo-example/"/>
    
    
  </entry>
  
</feed>
